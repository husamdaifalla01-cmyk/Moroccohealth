# P0.3 — Database Schema (V100)

## Prompt ID: P0.3
## Phase: 0 - Infrastructure Setup
## Estimated Time: 4-5 hours
## Prerequisites: P0.2 complete

---

## OVERVIEW

Define and create the core database schema for DAWA, including all tables, relationships, indexes, and Row Level Security policies.

## WORKSPACE PATHS

> **NOTE**: Documentation lives in `dawa-docs/`, app code in `dawa-ma/`.
> All migrations go in `dawa-ma/supabase/migrations/`.

---

## SCHEMA OVERVIEW

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           DAWA DATABASE SCHEMA                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CORE ENTITIES                                                              │
│  ─────────────                                                              │
│  users ─────────────┬── patients (1:1)                                      │
│                     ├── pharmacy_staff (1:N)                                │
│                     └── couriers (1:1)                                      │
│                                                                              │
│  pharmacies ────────┬── pharmacy_staff (1:N)                               │
│                     ├── pharmacy_inventory (1:N)                            │
│                     ├── orders (1:N)                                        │
│                     └── pharmacy_reviews (1:N)                              │
│                                                                              │
│  medications ───────┬── pharmacy_inventory (1:N)                           │
│                     └── order_items (1:N)                                   │
│                                                                              │
│  orders ────────────┬── order_items (1:N)                                  │
│                     ├── order_status_history (1:N)                          │
│                     └── prescription_usage (1:N)                            │
│                                                                              │
│  prescriptions ─────┬── prescription_items (1:N)                           │
│                     └── prescription_usage (1:N)                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## MIGRATION: 001_initial_schema.sql

Create file: `dawa-ma/supabase/migrations/20240101000001_initial_schema.sql`

```sql
-- ============================================================
-- DAWA INITIAL DATABASE SCHEMA
-- Version: 1.0.0
-- ============================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "postgis";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- ============================================================
-- ENUM TYPES
-- ============================================================

CREATE TYPE user_type AS ENUM ('PATIENT', 'PHARMACY_STAFF', 'COURIER', 'ADMIN');
CREATE TYPE order_status AS ENUM (
  'PENDING_CONFIRMATION',
  'CONFIRMED',
  'PREPARING',
  'READY_FOR_PICKUP',
  'PICKED_UP',
  'IN_TRANSIT',
  'ARRIVING',
  'DELIVERED',
  'CANCELLED'
);
CREATE TYPE pharmacy_staff_role AS ENUM ('OWNER', 'PHARMACIST', 'TECHNICIAN');
CREATE TYPE prescription_status AS ENUM ('ACTIVE', 'EXPIRED', 'FULLY_DISPENSED', 'ARCHIVED');

-- ============================================================
-- USERS & PROFILES
-- ============================================================

-- Users table (extends Supabase auth.users)
CREATE TABLE users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  phone TEXT UNIQUE NOT NULL,
  full_name TEXT,
  email TEXT,
  user_type user_type NOT NULL DEFAULT 'PATIENT',
  avatar_url TEXT,
  locale TEXT DEFAULT 'fr',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Patients profile
CREATE TABLE patients (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
  default_address JSONB,
  -- { street, city, lat, lng, notes }
  saved_addresses JSONB DEFAULT '[]'::jsonb,
  marketing_opt_in BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================
-- PHARMACIES
-- ============================================================

CREATE TABLE pharmacies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Basic info
  name TEXT NOT NULL,
  legal_name TEXT,
  license_number TEXT UNIQUE,
  
  -- Location
  address TEXT NOT NULL,
  city TEXT NOT NULL,
  latitude DOUBLE PRECISION NOT NULL,
  longitude DOUBLE PRECISION NOT NULL,
  location GEOGRAPHY(POINT, 4326),
  
  -- Contact
  phone TEXT NOT NULL,
  email TEXT,
  
  -- Business info
  operating_hours JSONB DEFAULT '{}'::jsonb,
  delivery_zones JSONB DEFAULT '[]'::jsonb,
  delivery_fee DECIMAL(6, 2) DEFAULT 15.00,
  min_order_amount DECIMAL(8, 2) DEFAULT 0,
  
  -- Media
  logo_url TEXT,
  cover_image_url TEXT,
  
  -- Status
  status TEXT DEFAULT 'PENDING', -- PENDING, ACTIVE, SUSPENDED
  is_accepting_orders BOOLEAN DEFAULT true,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Trigger to sync location from lat/lng
CREATE OR REPLACE FUNCTION sync_pharmacy_location()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.latitude IS NOT NULL AND NEW.longitude IS NOT NULL THEN
    NEW.location = ST_SetSRID(ST_MakePoint(NEW.longitude, NEW.latitude), 4326)::geography;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_pharmacy_location_sync
  BEFORE INSERT OR UPDATE OF latitude, longitude ON pharmacies
  FOR EACH ROW
  EXECUTE FUNCTION sync_pharmacy_location();

-- Spatial index
CREATE INDEX idx_pharmacies_location ON pharmacies USING GIST (location);
CREATE INDEX idx_pharmacies_city ON pharmacies(city);
CREATE INDEX idx_pharmacies_status ON pharmacies(status);

-- Pharmacy staff
CREATE TABLE pharmacy_staff (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pharmacy_id UUID NOT NULL REFERENCES pharmacies(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role pharmacy_staff_role NOT NULL DEFAULT 'TECHNICIAN',
  status TEXT DEFAULT 'ACTIVE',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(pharmacy_id, user_id)
);

CREATE INDEX idx_pharmacy_staff_pharmacy ON pharmacy_staff(pharmacy_id);
CREATE INDEX idx_pharmacy_staff_user ON pharmacy_staff(user_id);

-- ============================================================
-- MEDICATIONS
-- ============================================================

CREATE TABLE medications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Identity
  name TEXT NOT NULL,
  name_ar TEXT,
  generic_name TEXT,
  
  -- Details
  dosage TEXT,
  form TEXT, -- tablet, syrup, injection, etc.
  manufacturer TEXT,
  
  -- Pricing
  ppv DECIMAL(8, 2), -- Prix Public Vente (regulated)
  is_regulated_price BOOLEAN DEFAULT true,
  
  -- Classification
  category TEXT,
  requires_prescription BOOLEAN DEFAULT false,
  is_controlled_substance BOOLEAN DEFAULT false,
  
  -- Search
  search_vector TSVECTOR,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Full-text search index
CREATE INDEX idx_medications_search ON medications USING GIN(search_vector);
CREATE INDEX idx_medications_name ON medications(name);
CREATE INDEX idx_medications_category ON medications(category);

-- Trigger to update search vector
CREATE OR REPLACE FUNCTION update_medication_search_vector()
RETURNS TRIGGER AS $$
BEGIN
  NEW.search_vector = 
    setweight(to_tsvector('french', COALESCE(NEW.name, '')), 'A') ||
    setweight(to_tsvector('french', COALESCE(NEW.generic_name, '')), 'B') ||
    setweight(to_tsvector('french', COALESCE(NEW.manufacturer, '')), 'C');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_medication_search_vector
  BEFORE INSERT OR UPDATE ON medications
  FOR EACH ROW
  EXECUTE FUNCTION update_medication_search_vector();

-- Pharmacy inventory
CREATE TABLE pharmacy_inventory (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pharmacy_id UUID NOT NULL REFERENCES pharmacies(id) ON DELETE CASCADE,
  medication_id UUID NOT NULL REFERENCES medications(id) ON DELETE CASCADE,
  
  in_stock BOOLEAN DEFAULT true,
  quantity INTEGER,
  price DECIMAL(8, 2), -- Pharmacy's price (for OTC)
  
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(pharmacy_id, medication_id)
);

CREATE INDEX idx_pharmacy_inventory_pharmacy ON pharmacy_inventory(pharmacy_id);
CREATE INDEX idx_pharmacy_inventory_medication ON pharmacy_inventory(medication_id);
CREATE INDEX idx_pharmacy_inventory_stock ON pharmacy_inventory(pharmacy_id, in_stock);

-- ============================================================
-- PRESCRIPTIONS
-- ============================================================

CREATE TABLE prescriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  
  -- Image
  image_url TEXT NOT NULL,
  image_hash TEXT NOT NULL,
  
  -- Doctor info
  doctor_name TEXT,
  doctor_registration TEXT,
  
  -- Dates
  prescription_date DATE,
  expiry_date DATE,
  
  -- Status
  status prescription_status DEFAULT 'ACTIVE',
  extraction_confidence DECIMAL(3, 2),
  contains_controlled_substance BOOLEAN DEFAULT false,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(patient_id, image_hash)
);

CREATE INDEX idx_prescriptions_patient ON prescriptions(patient_id);
CREATE INDEX idx_prescriptions_status ON prescriptions(patient_id, status);

CREATE TABLE prescription_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  prescription_id UUID NOT NULL REFERENCES prescriptions(id) ON DELETE CASCADE,
  
  raw_text TEXT NOT NULL,
  medication_id UUID REFERENCES medications(id),
  medication_name TEXT NOT NULL,
  dosage TEXT,
  quantity INTEGER,
  frequency TEXT,
  
  is_controlled_substance BOOLEAN DEFAULT false,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_prescription_items_prescription ON prescription_items(prescription_id);

-- ============================================================
-- ORDERS
-- ============================================================

CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_number TEXT UNIQUE NOT NULL,
  
  -- Parties
  patient_id UUID NOT NULL REFERENCES patients(id),
  pharmacy_id UUID NOT NULL REFERENCES pharmacies(id),
  courier_id UUID REFERENCES users(id),
  
  -- Status
  status order_status DEFAULT 'PENDING_CONFIRMATION',
  
  -- Financial
  items_total DECIMAL(10, 2) NOT NULL DEFAULT 0,
  delivery_fee DECIMAL(6, 2) NOT NULL DEFAULT 0,
  total_amount DECIMAL(10, 2) NOT NULL DEFAULT 0,
  
  -- Delivery
  delivery_address JSONB NOT NULL,
  delivery_notes TEXT,
  
  -- Assignment
  assigned_to UUID REFERENCES users(id),
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  confirmed_at TIMESTAMPTZ,
  ready_at TIMESTAMPTZ,
  picked_up_at TIMESTAMPTZ,
  delivered_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  
  -- Cancellation
  cancelled_by TEXT, -- 'PATIENT', 'PHARMACY', 'SYSTEM'
  cancellation_reason TEXT
);

-- Generate order number
CREATE OR REPLACE FUNCTION generate_order_number()
RETURNS TRIGGER AS $$
BEGIN
  NEW.order_number = 'D' || TO_CHAR(NOW(), 'YYMMDD') || 
    LPAD(nextval('order_number_seq')::TEXT, 4, '0');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE SEQUENCE IF NOT EXISTS order_number_seq;

CREATE TRIGGER trg_order_number
  BEFORE INSERT ON orders
  FOR EACH ROW
  WHEN (NEW.order_number IS NULL)
  EXECUTE FUNCTION generate_order_number();

CREATE INDEX idx_orders_patient ON orders(patient_id, created_at DESC);
CREATE INDEX idx_orders_pharmacy ON orders(pharmacy_id, status, created_at DESC);
CREATE INDEX idx_orders_courier ON orders(courier_id) WHERE courier_id IS NOT NULL;
CREATE INDEX idx_orders_status ON orders(status);

-- Order items
CREATE TABLE order_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  
  medication_id UUID REFERENCES medications(id),
  prescription_id UUID REFERENCES prescriptions(id),
  prescription_item_id UUID REFERENCES prescription_items(id),
  
  name TEXT NOT NULL,
  dosage TEXT,
  quantity INTEGER NOT NULL DEFAULT 1,
  unit_price DECIMAL(8, 2) NOT NULL,
  total_price DECIMAL(10, 2) NOT NULL,
  
  requires_prescription BOOLEAN DEFAULT false,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_order_items_order ON order_items(order_id);

-- Order status history
CREATE TABLE order_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  status order_status NOT NULL,
  changed_by UUID REFERENCES users(id),
  reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_order_status_history_order ON order_status_history(order_id);

-- ============================================================
-- REVIEWS & RATINGS
-- ============================================================

CREATE TABLE pharmacy_reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pharmacy_id UUID NOT NULL REFERENCES pharmacies(id) ON DELETE CASCADE,
  patient_id UUID NOT NULL REFERENCES patients(id),
  order_id UUID REFERENCES orders(id),
  
  rating INTEGER NOT NULL CHECK (rating BETWEEN 1 AND 5),
  comment TEXT,
  
  status TEXT DEFAULT 'PENDING', -- PENDING, APPROVED, REJECTED
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(order_id)
);

CREATE INDEX idx_pharmacy_reviews_pharmacy ON pharmacy_reviews(pharmacy_id, status);

-- ============================================================
-- NOTIFICATIONS
-- ============================================================

CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  template_type TEXT NOT NULL,
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  
  order_id UUID REFERENCES orders(id),
  
  tier INTEGER DEFAULT 3,
  read_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_notifications_user ON notifications(user_id, created_at DESC);
CREATE INDEX idx_notifications_unread ON notifications(user_id, read_at) WHERE read_at IS NULL;

-- ============================================================
-- MESSAGES
-- ============================================================

CREATE TABLE conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID REFERENCES orders(id),
  patient_id UUID NOT NULL REFERENCES patients(id),
  pharmacy_id UUID REFERENCES pharmacies(id),
  courier_id UUID REFERENCES users(id),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES users(id),
  
  content TEXT NOT NULL,
  message_type TEXT DEFAULT 'text', -- text, image, system
  
  read_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_messages_conversation ON messages(conversation_id, created_at);

-- ============================================================
-- UPDATED_AT TRIGGER
-- ============================================================

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to all tables with updated_at
DO $$
DECLARE
  t TEXT;
BEGIN
  FOR t IN 
    SELECT table_name 
    FROM information_schema.columns 
    WHERE column_name = 'updated_at' 
      AND table_schema = 'public'
  LOOP
    EXECUTE format('
      CREATE TRIGGER trg_%I_updated_at
        BEFORE UPDATE ON %I
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column()
    ', t, t);
  END LOOP;
END;
$$;
```

---

## MIGRATION: 002_rls_policies.sql

Create file: `dawa-ma/supabase/migrations/20240101000002_rls_policies.sql`

```sql
-- ============================================================
-- ROW LEVEL SECURITY POLICIES
-- ============================================================

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE patients ENABLE ROW LEVEL SECURITY;
ALTER TABLE pharmacies ENABLE ROW LEVEL SECURITY;
ALTER TABLE pharmacy_staff ENABLE ROW LEVEL SECURITY;
ALTER TABLE medications ENABLE ROW LEVEL SECURITY;
ALTER TABLE pharmacy_inventory ENABLE ROW LEVEL SECURITY;
ALTER TABLE prescriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE prescription_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE pharmacy_reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- ============================================================
-- USERS
-- ============================================================

CREATE POLICY "Users can view own profile"
  ON users FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
  ON users FOR UPDATE
  USING (auth.uid() = id);

-- ============================================================
-- PATIENTS
-- ============================================================

CREATE POLICY "Patients can view own data"
  ON patients FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Patients can update own data"
  ON patients FOR UPDATE
  USING (auth.uid() = id);

-- ============================================================
-- PHARMACIES
-- ============================================================

CREATE POLICY "Anyone can view active pharmacies"
  ON pharmacies FOR SELECT
  USING (status = 'ACTIVE');

CREATE POLICY "Staff can view own pharmacy"
  ON pharmacies FOR SELECT
  USING (
    id IN (SELECT pharmacy_id FROM pharmacy_staff WHERE user_id = auth.uid())
  );

CREATE POLICY "Owners can update pharmacy"
  ON pharmacies FOR UPDATE
  USING (
    id IN (
      SELECT pharmacy_id FROM pharmacy_staff 
      WHERE user_id = auth.uid() AND role = 'OWNER'
    )
  );

-- ============================================================
-- MEDICATIONS
-- ============================================================

CREATE POLICY "Anyone can view medications"
  ON medications FOR SELECT
  USING (true);

-- ============================================================
-- ORDERS
-- ============================================================

CREATE POLICY "Patients can view own orders"
  ON orders FOR SELECT
  USING (patient_id = auth.uid());

CREATE POLICY "Patients can create orders"
  ON orders FOR INSERT
  WITH CHECK (patient_id = auth.uid());

CREATE POLICY "Pharmacy can view their orders"
  ON orders FOR SELECT
  USING (
    pharmacy_id IN (SELECT pharmacy_id FROM pharmacy_staff WHERE user_id = auth.uid())
  );

CREATE POLICY "Pharmacy can update their orders"
  ON orders FOR UPDATE
  USING (
    pharmacy_id IN (SELECT pharmacy_id FROM pharmacy_staff WHERE user_id = auth.uid())
  );

-- ============================================================
-- NOTIFICATIONS
-- ============================================================

CREATE POLICY "Users can view own notifications"
  ON notifications FOR SELECT
  USING (user_id = auth.uid());

CREATE POLICY "Users can update own notifications"
  ON notifications FOR UPDATE
  USING (user_id = auth.uid());
```

---

## APPLY MIGRATIONS

```bash
# From dawa-ma/
npx supabase db push

# Or for local dev
npx supabase migration up
```

---

## SUCCESS CRITERIA

- [ ] All enum types created
- [ ] Core tables created (users, pharmacies, medications, orders, etc.)
- [ ] PostGIS extension enabled with spatial indexes
- [ ] Full-text search configured for medications
- [ ] Order number sequence and trigger working
- [ ] updated_at triggers on all relevant tables
- [ ] RLS policies enabled and configured
- [ ] Migrations apply without errors

---

## NEXT STEP

After validation passes, proceed to:
→ `dawa-docs/prompts/phase-0/P0.4-typescript-types-generation.md`

Reference documentation:
→ `dawa-docs/docs/DAWA_MASTER.md`
→ `dawa-docs/docs/phases/PHASE_0.md`
