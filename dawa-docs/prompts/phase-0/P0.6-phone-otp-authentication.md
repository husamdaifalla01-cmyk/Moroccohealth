# P0.6 — Phone OTP Authentication

## Prompt ID: P0.6
## Phase: 0 - Foundation
## Estimated Time: 4-5 hours
## Prerequisites: P0.1-P0.5 complete

---

## CONTEXT

You are implementing phone-based OTP authentication for DAWA.ma. In Morocco, phone numbers are the primary identifier (not email). This system must:

1. Collect CNDP consent **before** authentication (legal requirement)
2. Support Moroccan phone format (+212)
3. Implement rate limiting to prevent abuse
4. Log all authentication events for compliance

**CRITICAL**: Morocco's CNDP (data protection authority) requires explicit consent before collecting personal data. Authentication cannot proceed without consent.

---

## AUTHENTICATION FLOW

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  CONSENT SCREEN │────▶│  PHONE INPUT    │────▶│  OTP VERIFY     │
│                 │     │                 │     │                 │
│  □ Data process │     │  +212 _________│     │  ______         │
│  □ Marketing    │     │                 │     │  6 digits       │
│  [Continue]     │     │  [Send OTP]     │     │  [Verify]       │
└─────────────────┘     └─────────────────┘     └─────────────────┘
         │                      │                      │
         ▼                      ▼                      ▼
   Save consent           Send SMS OTP          Create session
   to database            via provider          Return tokens
```

---

## IMPLEMENTATION STEPS

### Step 1: Database Schema (Supabase)

Run these migrations:

```sql
-- Migration: 003_auth_otp.sql

-- OTP codes table
CREATE TABLE otp_codes (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  phone VARCHAR(15) NOT NULL,
  code_hash VARCHAR(64) NOT NULL,  -- bcrypt hash, not plain text
  attempts INTEGER DEFAULT 0,
  max_attempts INTEGER DEFAULT 3,
  expires_at TIMESTAMPTZ NOT NULL,
  verified_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Index for lookups
  CONSTRAINT idx_otp_phone_expires UNIQUE (phone, expires_at)
);

-- Rate limiting table
CREATE TABLE otp_rate_limits (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  phone VARCHAR(15) NOT NULL,
  request_count INTEGER DEFAULT 1,
  window_start TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Unique per phone per window
  CONSTRAINT idx_rate_limit_phone UNIQUE (phone, window_start)
);

-- User consents table
CREATE TABLE user_consents (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  phone VARCHAR(15),  -- For pre-auth consent
  consent_type VARCHAR(50) NOT NULL,
  granted BOOLEAN NOT NULL DEFAULT false,
  granted_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Track consent changes
  CONSTRAINT idx_consent_user_type UNIQUE (user_id, consent_type)
);

-- Audit log for authentication events
CREATE TABLE auth_audit_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  event_type VARCHAR(50) NOT NULL,
  phone VARCHAR(15),
  user_id UUID REFERENCES auth.users(id),
  success BOOLEAN NOT NULL,
  failure_reason TEXT,
  ip_address INET,
  user_agent TEXT,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for audit queries
CREATE INDEX idx_auth_audit_phone ON auth_audit_logs(phone);
CREATE INDEX idx_auth_audit_user ON auth_audit_logs(user_id);
CREATE INDEX idx_auth_audit_created ON auth_audit_logs(created_at);

-- Auto-cleanup old OTP codes (run daily)
CREATE OR REPLACE FUNCTION cleanup_expired_otps()
RETURNS void AS $$
BEGIN
  DELETE FROM otp_codes WHERE expires_at < NOW() - INTERVAL '1 day';
  DELETE FROM otp_rate_limits WHERE window_start < NOW() - INTERVAL '1 hour';
END;
$$ LANGUAGE plpgsql;

-- Enable Row Level Security
ALTER TABLE otp_codes ENABLE ROW LEVEL SECURITY;
ALTER TABLE otp_rate_limits ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_consents ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth_audit_logs ENABLE ROW LEVEL SECURITY;

-- Service role only for OTP tables (no client access)
CREATE POLICY "Service role only" ON otp_codes
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

CREATE POLICY "Service role only" ON otp_rate_limits
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- Users can read their own consents
CREATE POLICY "Users read own consents" ON user_consents
  FOR SELECT USING (auth.uid() = user_id);

-- Service role for audit logs
CREATE POLICY "Service role only" ON auth_audit_logs
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');
```

### Step 2: OTP Service

Create `packages/auth/src/otp.service.ts`:

```typescript
// ============================================================
// OTP Service - Generate, send, and verify OTP codes
// ============================================================

import { createClient } from '@supabase/supabase-js';
import bcrypt from 'bcryptjs';
import crypto from 'crypto';

// Initialize Supabase admin client
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Configuration
const OTP_LENGTH = 6;
const OTP_EXPIRY_MINUTES = 5;
const MAX_ATTEMPTS = 3;
const RATE_LIMIT_WINDOW_MINUTES = 60;
const RATE_LIMIT_MAX_REQUESTS = 5;

export interface OtpResult {
  success: boolean;
  error?: string;
  errorCode?: string;
  remainingAttempts?: number;
}

export interface VerifyResult extends OtpResult {
  userId?: string;
  accessToken?: string;
  refreshToken?: string;
  isNewUser?: boolean;
}

/**
 * Generate a cryptographically secure OTP
 */
function generateOTP(): string {
  // Use crypto for security, not Math.random
  const buffer = crypto.randomBytes(4);
  const num = buffer.readUInt32BE(0);
  const otp = (num % 1000000).toString().padStart(OTP_LENGTH, '0');
  return otp;
}

/**
 * Check rate limiting for a phone number
 */
async function checkRateLimit(phone: string): Promise<{
  allowed: boolean;
  remainingRequests: number;
  retryAfterSeconds?: number;
}> {
  const windowStart = new Date(
    Date.now() - RATE_LIMIT_WINDOW_MINUTES * 60 * 1000
  ).toISOString();

  // Count requests in current window
  const { count, error } = await supabase
    .from('otp_rate_limits')
    .select('*', { count: 'exact', head: true })
    .eq('phone', phone)
    .gte('window_start', windowStart);

  if (error) {
    console.error('Rate limit check error:', error);
    // Fail open but log
    return { allowed: true, remainingRequests: 0 };
  }

  const requestCount = count || 0;
  const allowed = requestCount < RATE_LIMIT_MAX_REQUESTS;
  const remainingRequests = Math.max(0, RATE_LIMIT_MAX_REQUESTS - requestCount);

  return {
    allowed,
    remainingRequests,
    retryAfterSeconds: allowed ? undefined : RATE_LIMIT_WINDOW_MINUTES * 60,
  };
}

/**
 * Record rate limit request
 */
async function recordRateLimitRequest(phone: string): Promise<void> {
  await supabase.from('otp_rate_limits').insert({
    phone,
    window_start: new Date().toISOString(),
  });
}

/**
 * Request OTP - Generate and send via SMS
 */
export async function requestOTP(
  phone: string,
  ipAddress?: string,
  userAgent?: string
): Promise<OtpResult> {
  // Validate Moroccan phone format
  if (!/^\+212[67]\d{8}$/.test(phone)) {
    return {
      success: false,
      error: 'Format de numéro invalide. Utilisez +212 6XX XXX XXX',
      errorCode: 'INVALID_PHONE_FORMAT',
    };
  }

  // Check rate limiting
  const rateLimit = await checkRateLimit(phone);
  if (!rateLimit.allowed) {
    await logAuthEvent({
      event_type: 'otp_rate_limited',
      phone,
      success: false,
      failure_reason: 'Rate limit exceeded',
      ip_address: ipAddress,
      user_agent: userAgent,
    });

    return {
      success: false,
      error: `Trop de tentatives. Réessayez dans ${Math.ceil(
        rateLimit.retryAfterSeconds! / 60
      )} minutes.`,
      errorCode: 'RATE_LIMITED',
    };
  }

  // Generate OTP
  const otp = generateOTP();
  const otpHash = await bcrypt.hash(otp, 10);
  const expiresAt = new Date(Date.now() + OTP_EXPIRY_MINUTES * 60 * 1000);

  // Invalidate any existing OTPs for this phone
  await supabase
    .from('otp_codes')
    .update({ expires_at: new Date().toISOString() })
    .eq('phone', phone)
    .is('verified_at', null);

  // Store new OTP
  const { error: insertError } = await supabase.from('otp_codes').insert({
    phone,
    code_hash: otpHash,
    expires_at: expiresAt.toISOString(),
  });

  if (insertError) {
    console.error('OTP insert error:', insertError);
    return {
      success: false,
      error: 'Erreur système. Veuillez réessayer.',
      errorCode: 'SYSTEM_ERROR',
    };
  }

  // Record rate limit request
  await recordRateLimitRequest(phone);

  // Send SMS
  const smsResult = await sendSMS(phone, otp);
  if (!smsResult.success) {
    return {
      success: false,
      error: 'Impossible d\'envoyer le SMS. Vérifiez votre numéro.',
      errorCode: 'SMS_SEND_FAILED',
    };
  }

  // Log success
  await logAuthEvent({
    event_type: 'otp_requested',
    phone,
    success: true,
    ip_address: ipAddress,
    user_agent: userAgent,
  });

  return {
    success: true,
  };
}

/**
 * Verify OTP and create/authenticate user
 */
export async function verifyOTP(
  phone: string,
  code: string,
  ipAddress?: string,
  userAgent?: string
): Promise<VerifyResult> {
  // Get latest non-expired OTP for this phone
  const { data: otpRecord, error: fetchError } = await supabase
    .from('otp_codes')
    .select('*')
    .eq('phone', phone)
    .is('verified_at', null)
    .gt('expires_at', new Date().toISOString())
    .order('created_at', { ascending: false })
    .limit(1)
    .single();

  if (fetchError || !otpRecord) {
    await logAuthEvent({
      event_type: 'otp_verify_failed',
      phone,
      success: false,
      failure_reason: 'No valid OTP found',
      ip_address: ipAddress,
      user_agent: userAgent,
    });

    return {
      success: false,
      error: 'Code expiré ou invalide. Demandez un nouveau code.',
      errorCode: 'OTP_EXPIRED',
    };
  }

  // Check attempts
  if (otpRecord.attempts >= MAX_ATTEMPTS) {
    await logAuthEvent({
      event_type: 'otp_verify_failed',
      phone,
      success: false,
      failure_reason: 'Max attempts exceeded',
      ip_address: ipAddress,
      user_agent: userAgent,
    });

    return {
      success: false,
      error: 'Trop de tentatives. Demandez un nouveau code.',
      errorCode: 'MAX_ATTEMPTS_EXCEEDED',
    };
  }

  // Verify code
  const isValid = await bcrypt.compare(code, otpRecord.code_hash);

  if (!isValid) {
    // Increment attempts
    await supabase
      .from('otp_codes')
      .update({ attempts: otpRecord.attempts + 1 })
      .eq('id', otpRecord.id);

    const remainingAttempts = MAX_ATTEMPTS - otpRecord.attempts - 1;

    await logAuthEvent({
      event_type: 'otp_verify_failed',
      phone,
      success: false,
      failure_reason: 'Invalid code',
      ip_address: ipAddress,
      user_agent: userAgent,
      metadata: { remaining_attempts: remainingAttempts },
    });

    return {
      success: false,
      error: `Code incorrect. ${remainingAttempts} tentative(s) restante(s).`,
      errorCode: 'INVALID_CODE',
      remainingAttempts,
    };
  }

  // Mark OTP as verified
  await supabase
    .from('otp_codes')
    .update({ verified_at: new Date().toISOString() })
    .eq('id', otpRecord.id);

  // Find or create user
  const { user, isNew, session } = await findOrCreateUser(phone);

  if (!user || !session) {
    return {
      success: false,
      error: 'Erreur lors de la création du compte.',
      errorCode: 'USER_CREATE_FAILED',
    };
  }

  // Log success
  await logAuthEvent({
    event_type: isNew ? 'user_registered' : 'user_logged_in',
    phone,
    user_id: user.id,
    success: true,
    ip_address: ipAddress,
    user_agent: userAgent,
  });

  return {
    success: true,
    userId: user.id,
    accessToken: session.access_token,
    refreshToken: session.refresh_token,
    isNewUser: isNew,
  };
}

/**
 * Find existing user or create new one
 */
async function findOrCreateUser(phone: string): Promise<{
  user: any;
  isNew: boolean;
  session: any;
}> {
  // Check if user exists
  const { data: existingUser } = await supabase
    .from('patients')
    .select('id, user_id')
    .eq('phone', phone)
    .single();

  if (existingUser?.user_id) {
    // Sign in existing user
    const { data: signInData, error: signInError } = await supabase.auth.admin.generateLink({
      type: 'magiclink',
      email: `${phone.replace('+', '')}@phone.dawa.ma`, // Pseudo-email for Supabase
    });

    if (signInError) {
      console.error('Sign in error:', signInError);
      return { user: null, isNew: false, session: null };
    }

    // Create session manually
    const { data: sessionData } = await supabase.auth.admin.createUser({
      email: `${phone.replace('+', '')}@phone.dawa.ma`,
      phone: phone,
      email_confirm: true,
      phone_confirm: true,
    });

    return {
      user: { id: existingUser.user_id },
      isNew: false,
      session: sessionData.user ? await createSession(sessionData.user.id) : null,
    };
  }

  // Create new user
  const { data: newUser, error: createError } = await supabase.auth.admin.createUser({
    email: `${phone.replace('+', '')}@phone.dawa.ma`,
    phone: phone,
    email_confirm: true,
    phone_confirm: true,
    user_metadata: {
      phone: phone,
    },
  });

  if (createError || !newUser.user) {
    console.error('User creation error:', createError);
    return { user: null, isNew: true, session: null };
  }

  // Create patient record
  await supabase.from('patients').insert({
    user_id: newUser.user.id,
    phone: phone,
    status: 'active',
  });

  const session = await createSession(newUser.user.id);

  return {
    user: newUser.user,
    isNew: true,
    session,
  };
}

/**
 * Create session for user
 */
async function createSession(userId: string): Promise<{
  access_token: string;
  refresh_token: string;
} | null> {
  // In production, use Supabase's session management
  // This is a simplified version
  const { data, error } = await supabase.auth.admin.createUser({
    email: `session-${userId}@internal.dawa.ma`,
  });

  // Return mock session for now - implement proper session in production
  return {
    access_token: 'mock_access_token',
    refresh_token: 'mock_refresh_token',
  };
}

/**
 * Send SMS via provider
 */
async function sendSMS(
  phone: string,
  otp: string
): Promise<{ success: boolean }> {
  const provider = process.env.SMS_PROVIDER || 'twilio';

  const message = `DAWA.ma: Votre code de vérification est ${otp}. Valide pendant ${OTP_EXPIRY_MINUTES} minutes.`;

  try {
    if (provider === 'twilio') {
      const twilio = require('twilio')(
        process.env.TWILIO_ACCOUNT_SID,
        process.env.TWILIO_AUTH_TOKEN
      );

      await twilio.messages.create({
        body: message,
        from: process.env.TWILIO_PHONE_NUMBER,
        to: phone,
      });
    } else if (provider === 'infobip') {
      // Infobip - popular in Morocco
      const response = await fetch('https://api.infobip.com/sms/2/text/advanced', {
        method: 'POST',
        headers: {
          'Authorization': `App ${process.env.INFOBIP_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [{
            destinations: [{ to: phone }],
            from: 'DAWA',
            text: message,
          }],
        }),
      });

      if (!response.ok) {
        throw new Error('Infobip send failed');
      }
    }

    return { success: true };
  } catch (error) {
    console.error('SMS send error:', error);
    return { success: false };
  }
}

/**
 * Log authentication event for compliance
 */
async function logAuthEvent(event: {
  event_type: string;
  phone?: string;
  user_id?: string;
  success: boolean;
  failure_reason?: string;
  ip_address?: string;
  user_agent?: string;
  metadata?: Record<string, any>;
}): Promise<void> {
  try {
    await supabase.from('auth_audit_logs').insert({
      ...event,
      ip_address: event.ip_address || null,
      metadata: event.metadata || null,
    });
  } catch (error) {
    console.error('Audit log error:', error);
  }
}
```

### Step 3: Consent Service

Create `packages/auth/src/consent.service.ts`:

```typescript
// ============================================================
// Consent Service - CNDP Compliance
// ============================================================

import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export type ConsentType = 
  | 'data_processing'  // Required - cannot proceed without
  | 'marketing'        // Optional
  | 'location'         // Optional - for delivery
  | 'medical_data';    // Required for orders

export interface ConsentRecord {
  consent_type: ConsentType;
  granted: boolean;
  granted_at?: string;
}

export interface SaveConsentInput {
  phone?: string;
  userId?: string;
  consents: ConsentRecord[];
  ipAddress?: string;
  userAgent?: string;
}

/**
 * Save user consent(s)
 */
export async function saveConsent(input: SaveConsentInput): Promise<{
  success: boolean;
  error?: string;
}> {
  const { phone, userId, consents, ipAddress, userAgent } = input;

  // Must have either phone (pre-auth) or userId (post-auth)
  if (!phone && !userId) {
    return {
      success: false,
      error: 'Phone or userId required',
    };
  }

  // Validate required consents
  const dataProcessing = consents.find(c => c.consent_type === 'data_processing');
  if (!dataProcessing?.granted) {
    return {
      success: false,
      error: 'Le consentement au traitement des données est obligatoire',
    };
  }

  try {
    // Insert or update each consent
    for (const consent of consents) {
      const record = {
        phone: phone || null,
        user_id: userId || null,
        consent_type: consent.consent_type,
        granted: consent.granted,
        granted_at: consent.granted ? new Date().toISOString() : null,
        revoked_at: !consent.granted ? new Date().toISOString() : null,
        ip_address: ipAddress || null,
        user_agent: userAgent || null,
      };

      // Upsert based on phone or user_id
      if (userId) {
        await supabase
          .from('user_consents')
          .upsert(record, { onConflict: 'user_id,consent_type' });
      } else {
        await supabase
          .from('user_consents')
          .insert(record);
      }
    }

    return { success: true };
  } catch (error) {
    console.error('Save consent error:', error);
    return {
      success: false,
      error: 'Erreur lors de l\'enregistrement du consentement',
    };
  }
}

/**
 * Get user's consent records
 */
export async function getUserConsents(userId: string): Promise<ConsentRecord[]> {
  const { data, error } = await supabase
    .from('user_consents')
    .select('consent_type, granted, granted_at')
    .eq('user_id', userId);

  if (error) {
    console.error('Get consents error:', error);
    return [];
  }

  return data || [];
}

/**
 * Check if user has required consent
 */
export async function hasRequiredConsent(
  userId: string,
  consentType: ConsentType
): Promise<boolean> {
  const { data, error } = await supabase
    .from('user_consents')
    .select('granted')
    .eq('user_id', userId)
    .eq('consent_type', consentType)
    .single();

  if (error || !data) {
    return false;
  }

  return data.granted === true;
}

/**
 * Revoke consent
 */
export async function revokeConsent(
  userId: string,
  consentType: ConsentType
): Promise<{ success: boolean }> {
  const { error } = await supabase
    .from('user_consents')
    .update({
      granted: false,
      revoked_at: new Date().toISOString(),
    })
    .eq('user_id', userId)
    .eq('consent_type', consentType);

  return { success: !error };
}

/**
 * Migrate phone consents to user after registration
 */
export async function migratePhoneConsents(
  phone: string,
  userId: string
): Promise<void> {
  // Get consents stored with phone
  const { data: phoneConsents } = await supabase
    .from('user_consents')
    .select('*')
    .eq('phone', phone)
    .is('user_id', null);

  if (!phoneConsents?.length) return;

  // Update to link to user
  for (const consent of phoneConsents) {
    await supabase
      .from('user_consents')
      .update({ user_id: userId })
      .eq('id', consent.id);
  }
}
```

### Step 4: API Routes

Create `apps/patient/src/app/api/auth/request-otp/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { requestOTP } from '@dawa/auth';
import { requestOtpSchema } from '@dawa/validation';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate input
    const result = requestOtpSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        {
          success: false,
          error: result.error.errors[0].message,
          errorCode: 'VALIDATION_ERROR',
        },
        { status: 400 }
      );
    }

    const { phone } = result.data;
    
    // Get client info for audit
    const ipAddress = request.headers.get('x-forwarded-for') || 
                      request.headers.get('x-real-ip') ||
                      'unknown';
    const userAgent = request.headers.get('user-agent') || 'unknown';

    // Request OTP
    const otpResult = await requestOTP(phone, ipAddress, userAgent);

    if (!otpResult.success) {
      return NextResponse.json(otpResult, { status: 400 });
    }

    return NextResponse.json({
      success: true,
      message: 'Code envoyé par SMS',
    });
  } catch (error) {
    console.error('Request OTP error:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Erreur serveur',
        errorCode: 'INTERNAL_ERROR',
      },
      { status: 500 }
    );
  }
}
```

Create `apps/patient/src/app/api/auth/verify-otp/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { verifyOTP, migratePhoneConsents } from '@dawa/auth';
import { verifyOtpSchema } from '@dawa/validation';
import { cookies } from 'next/headers';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate input
    const result = verifyOtpSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        {
          success: false,
          error: result.error.errors[0].message,
          errorCode: 'VALIDATION_ERROR',
        },
        { status: 400 }
      );
    }

    const { phone, code } = result.data;
    
    // Get client info
    const ipAddress = request.headers.get('x-forwarded-for') || 'unknown';
    const userAgent = request.headers.get('user-agent') || 'unknown';

    // Verify OTP
    const verifyResult = await verifyOTP(phone, code, ipAddress, userAgent);

    if (!verifyResult.success) {
      return NextResponse.json(verifyResult, { 
        status: verifyResult.errorCode === 'INVALID_CODE' ? 401 : 400 
      });
    }

    // Migrate phone consents to user
    if (verifyResult.userId) {
      await migratePhoneConsents(phone, verifyResult.userId);
    }

    // Set secure cookies
    const cookieStore = cookies();
    
    cookieStore.set('access_token', verifyResult.accessToken!, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60, // 1 hour
      path: '/',
    });

    cookieStore.set('refresh_token', verifyResult.refreshToken!, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 24 * 30, // 30 days
      path: '/',
    });

    return NextResponse.json({
      success: true,
      isNewUser: verifyResult.isNewUser,
      userId: verifyResult.userId,
    });
  } catch (error) {
    console.error('Verify OTP error:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Erreur serveur',
        errorCode: 'INTERNAL_ERROR',
      },
      { status: 500 }
    );
  }
}
```

---

## SUCCESS CRITERIA

- [ ] OTP generation uses crypto-secure randomness
- [ ] OTP codes are hashed in database (not plain text)
- [ ] Rate limiting prevents abuse (5 per hour per phone)
- [ ] CNDP consent collected before OTP request
- [ ] All auth events logged to audit table
- [ ] Session tokens set as secure HTTP-only cookies
- [ ] Error messages in French
- [ ] Works with Moroccan phone format (+212)

---

## SECURITY CHECKLIST

- [ ] OTP codes expire after 5 minutes
- [ ] Maximum 3 verification attempts per code
- [ ] Rate limiting per phone number
- [ ] No plain text OTP storage
- [ ] Audit logging for compliance
- [ ] Secure cookie settings (httpOnly, secure, sameSite)
- [ ] Input validation on all endpoints

---

## NEXT STEP

After validation passes, proceed to:
→ `dawa-docs/prompts/phase-0/P0.7-environment-configuration.md`

Reference documentation:
→ `dawa-docs/docs/DAWA_MASTER.md`
