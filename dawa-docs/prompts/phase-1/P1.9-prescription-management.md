# P1.9 — Prescription Management (V100)

## Prompt ID: P1.9
## Phase: 1 - Patient Web App
## Estimated Time: 10-12 hours
## Prerequisites: P1.8 complete

---

## STRATEGIC CONTEXT

### What Problem Are We Solving?

Prescription management in DAWA is NOT about replacing the physical prescription—Moroccan law still requires pharmacies to verify original documents for controlled medications. Instead, we're solving these problems:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    THE REAL PROBLEMS                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  PROBLEM 1: ORDER PRE-QUALIFICATION                                         │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Without prescription upload:                                               │
│  • Patient orders "blood pressure medication"                              │
│  • Pharmacy asks: "Which one? What dosage? Where's prescription?"          │
│  • Back-and-forth chat delays order by 30+ minutes                        │
│  • Frustration on both sides                                               │
│                                                                              │
│  With prescription upload:                                                 │
│  • Patient uploads prescription image                                      │
│  • System extracts: "Amlodipine 5mg, 2 boxes, Dr. Benali"                 │
│  • Patient confirms: "Yes, that's right"                                  │
│  • Pharmacy receives clear, structured order                              │
│  • Order ready 3x faster                                                  │
│                                                                              │
│  PROBLEM 2: PATIENT RECORD KEEPING                                         │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Current reality:                                                          │
│  • Patients lose paper prescriptions                                      │
│  • "What was that medication the doctor gave me last month?"              │
│  • No history of what was prescribed vs what was purchased                │
│                                                                              │
│  With DAWA:                                                                │
│  • All prescriptions stored digitally                                     │
│  • Searchable medication history                                          │
│  • "Reorder from this prescription" functionality                        │
│  • Expiry reminders before prescription becomes invalid                  │
│                                                                              │
│  PROBLEM 3: PREVENTING MISUSE                                              │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Risk scenarios:                                                           │
│  • Same prescription used multiple times at different pharmacies          │
│  • Expired prescriptions being used for orders                            │
│  • Controlled substances ordered for delivery (illegal)                   │
│                                                                              │
│  Our safeguards:                                                           │
│  • Hash-based duplicate detection                                         │
│  • Automatic expiry calculation and enforcement                          │
│  • Controlled substance detection → block + redirect to in-store         │
│  • Usage tracking per prescription                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Morocco Prescription Legal Context

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MOROCCAN PRESCRIPTION LAW                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  PRESCRIPTION REQUIREMENTS (Code de la Pharmacie)                          │
│  ─────────────────────────────────────────────────────────────────────────   │
│                                                                              │
│  A valid prescription MUST include:                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. Doctor's full name                                              │   │
│  │  2. Doctor's specialty                                              │   │
│  │  3. "Numéro du Tableau" (registration number with Medical Council)  │   │
│  │  4. Doctor's address and phone                                      │   │
│  │  5. Patient name (often incomplete in practice)                     │   │
│  │  6. Date of prescription                                            │   │
│  │  7. Medication names with dosage and quantity                       │   │
│  │  8. Doctor's signature (handwritten)                                │   │
│  │  9. Optional: duration of treatment                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  VALIDITY PERIODS                                                          │
│  ─────────────────────────────────────────────────────────────────────────   │
│  • Standard prescriptions: 30 days from date written                      │
│  • Chronic disease prescriptions: May specify up to 3 months             │
│  • Controlled substances (Liste I): Single use, non-renewable            │
│  • Psychotropes (Liste II): Requires "carnet à souches" (special pad)    │
│                                                                              │
│  CONTROLLED SUBSTANCES - CRITICAL                                          │
│  ─────────────────────────────────────────────────────────────────────────   │
│  The following CANNOT be delivered via DAWA:                              │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  ❌ Morphine and derivatives (tramadol, codeine combos)             │   │
│  │  ❌ Benzodiazepines (diazepam, alprazolam, etc.)                    │   │
│  │  ❌ Barbiturates                                                     │   │
│  │  ❌ Amphetamines (including ADHD medications)                       │   │
│  │  ❌ Any medication requiring "carnet à souches"                     │   │
│  │                                                                      │   │
│  │  Detection: Match extracted medication names against controlled     │   │
│  │  substances database. If match → BLOCK order, inform patient.      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  DIGITAL vs PHYSICAL                                                       │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Important legal note:                                                     │
│  • Digital image of prescription is for PRE-QUALIFICATION only            │
│  • For standard medications: Pharmacy can dispense based on image        │
│  • For antibiotics: Image acceptable, but exact quantity must match      │
│  • For controlled: Patient MUST present physical original in-store       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### OCR Strategy Decision

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    OCR TECHNOLOGY ANALYSIS                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  THE CHALLENGE                                                              │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Moroccan prescriptions are notoriously difficult to read:                 │
│  • Doctor handwriting (famously illegible)                                 │
│  • Mixed French/Arabic text                                                │
│  • Medical abbreviations ("Dolip" = Doliprane, "Amoxi" = Amoxicilline)   │
│  • Varying paper quality and lighting in photos                           │
│  • Stamps, signatures overlapping text                                    │
│                                                                              │
│  OPTION A: Google Cloud Vision                                             │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Pros:                                                                     │
│  • Excellent on typed/printed text (~95% accuracy)                        │
│  • Good Arabic support                                                    │
│  • Well-documented API                                                    │
│                                                                              │
│  Cons:                                                                     │
│  • ~60% accuracy on doctor handwriting (unacceptable)                    │
│  • $1.50 per 1000 images                                                  │
│  • Data sent to Google servers (CNDP privacy concerns)                   │
│  • Returns raw text, needs post-processing for structure                 │
│                                                                              │
│  OPTION B: Tesseract OCR (Self-hosted)                                    │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Pros:                                                                     │
│  • Free and open source                                                   │
│  • Data stays on our servers                                              │
│  • Can be customized/trained                                              │
│                                                                              │
│  Cons:                                                                     │
│  • ~30% accuracy on handwriting (even worse)                             │
│  • Requires significant ML expertise to improve                          │
│  • High maintenance burden                                                │
│  • Poor Arabic support out of the box                                    │
│                                                                              │
│  OPTION C: Claude Vision API (✓ CHOSEN)                                   │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Pros:                                                                     │
│  • ~75% accuracy on handwriting (best available)                         │
│  • UNDERSTANDS CONTEXT ("this is a medical prescription")                │
│  • Can return STRUCTURED JSON directly                                    │
│  • Handles mixed French/Arabic naturally                                  │
│  • Can flag suspicious patterns                                           │
│  • $0.003 per image (very affordable)                                    │
│  • Already using Anthropic API for other features                        │
│                                                                              │
│  Cons:                                                                     │
│  • Still not perfect on very poor handwriting                            │
│  • Needs fallback for low-confidence extractions                        │
│                                                                              │
│  DECISION: Claude Vision with manual fallback                             │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Flow:                                                                     │
│  1. Try Claude Vision extraction                                          │
│  2. If confidence < 70%: Show user for manual review/correction          │
│  3. If confidence < 40%: Fall back to fully manual entry                 │
│  4. Always allow user to edit extracted data                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## DATA MODEL

### Prescription Tables

```sql
-- ============================================================
-- PRESCRIPTION MANAGEMENT SCHEMA
-- ============================================================

-- Main prescriptions table
CREATE TABLE prescriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  
  -- Image storage
  image_url TEXT NOT NULL,           -- Supabase Storage URL
  image_hash TEXT NOT NULL,          -- SHA-256 for duplicate detection
  
  -- Extracted doctor information
  doctor_name TEXT,
  doctor_specialty TEXT,
  doctor_registration TEXT,          -- "Numéro du Tableau"
  doctor_phone TEXT,
  doctor_address TEXT,
  
  -- Prescription metadata
  prescription_date DATE,            -- Date written by doctor
  expiry_date DATE,                  -- Calculated: prescription_date + validity_days
  validity_days INTEGER DEFAULT 30,  -- Standard 30, can be extended for chronic
  
  -- Patient info (if extracted)
  patient_name_extracted TEXT,       -- What was written on prescription
  
  -- Extraction metadata
  extraction_status TEXT DEFAULT 'PENDING', 
    -- PENDING, PROCESSING, EXTRACTED, NEEDS_REVIEW, FAILED
  extraction_confidence DECIMAL(3,2), -- 0.00 to 1.00
  raw_extraction_data JSONB,         -- Full Claude response for debugging
  
  -- Flags
  contains_controlled_substance BOOLEAN DEFAULT false,
  controlled_substance_names TEXT[], -- Which ones detected
  needs_manual_review BOOLEAN DEFAULT false,
  
  -- Status
  status TEXT DEFAULT 'ACTIVE',      -- ACTIVE, EXPIRED, FULLY_DISPENSED, ARCHIVED
  
  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Prevent duplicate uploads
  UNIQUE(patient_id, image_hash)
);

CREATE INDEX idx_prescriptions_patient ON prescriptions(patient_id, created_at DESC);
CREATE INDEX idx_prescriptions_status ON prescriptions(patient_id, status);
CREATE INDEX idx_prescriptions_expiry ON prescriptions(expiry_date) WHERE status = 'ACTIVE';

-- Extracted prescription items
CREATE TABLE prescription_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  prescription_id UUID NOT NULL REFERENCES prescriptions(id) ON DELETE CASCADE,
  
  -- Raw extracted text
  raw_text TEXT NOT NULL,            -- Exactly as written: "Dolip 1000 x2"
  
  -- Parsed/matched data
  medication_id UUID REFERENCES medications(id), -- NULL if couldn't match
  medication_name TEXT NOT NULL,     -- Cleaned name: "Doliprane 1000mg"
  dosage TEXT,                       -- "1000mg"
  quantity INTEGER,                  -- Number of boxes/units
  frequency TEXT,                    -- "3 fois par jour"
  duration TEXT,                     -- "pendant 7 jours"
  instructions TEXT,                 -- Any additional notes
  
  -- Matching metadata
  match_confidence DECIMAL(3,2),     -- How confident is medication match
  match_method TEXT,                 -- 'exact', 'fuzzy', 'manual', 'unmatched'
  needs_review BOOLEAN DEFAULT false,
  
  -- Controlled substance flag
  is_controlled_substance BOOLEAN DEFAULT false,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_prescription_items_prescription ON prescription_items(prescription_id);
CREATE INDEX idx_prescription_items_medication ON prescription_items(medication_id);

-- Track prescription usage across orders
CREATE TABLE prescription_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  prescription_id UUID NOT NULL REFERENCES prescriptions(id),
  prescription_item_id UUID NOT NULL REFERENCES prescription_items(id),
  order_id UUID NOT NULL REFERENCES orders(id),
  
  -- What was dispensed
  quantity_dispensed INTEGER NOT NULL,
  
  -- Audit
  dispensed_at TIMESTAMPTZ DEFAULT NOW(),
  dispensed_by UUID REFERENCES users(id), -- Pharmacist who verified
  pharmacy_id UUID NOT NULL REFERENCES pharmacies(id)
);

CREATE INDEX idx_prescription_usage_prescription ON prescription_usage(prescription_id);
CREATE INDEX idx_prescription_usage_order ON prescription_usage(order_id);

-- Controlled substances database (for detection)
CREATE TABLE controlled_substances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  name_variants TEXT[],              -- ["tramadol", "tramal", "contramal"]
  category TEXT NOT NULL,            -- 'OPIOID', 'BENZODIAZEPINE', 'BARBITURATE', etc.
  schedule TEXT NOT NULL,            -- 'LISTE_I', 'LISTE_II', 'TABLEAU_A'
  requires_carnet BOOLEAN DEFAULT false,
  delivery_allowed BOOLEAN DEFAULT false
);

-- Seed controlled substances
INSERT INTO controlled_substances (name, name_variants, category, schedule, requires_carnet) VALUES
('Tramadol', ARRAY['tramadol', 'tramal', 'contramal', 'topalgic'], 'OPIOID', 'LISTE_I', true),
('Codéine', ARRAY['codeine', 'codéine', 'néocodion', 'paderyl'], 'OPIOID', 'LISTE_I', true),
('Morphine', ARRAY['morphine', 'moscontin', 'skenan'], 'OPIOID', 'LISTE_I', true),
('Diazépam', ARRAY['diazepam', 'diazépam', 'valium'], 'BENZODIAZEPINE', 'LISTE_II', true),
('Alprazolam', ARRAY['alprazolam', 'xanax'], 'BENZODIAZEPINE', 'LISTE_II', true),
('Lorazépam', ARRAY['lorazepam', 'lorazépam', 'temesta'], 'BENZODIAZEPINE', 'LISTE_II', true),
('Zolpidem', ARRAY['zolpidem', 'stilnox'], 'HYPNOTIC', 'LISTE_II', true),
('Méthylphénidate', ARRAY['methylphenidate', 'méthylphénidate', 'ritaline', 'concerta'], 'STIMULANT', 'LISTE_I', true);
```

### Expiry Check Function

```sql
-- Check if prescription is still valid
CREATE OR REPLACE FUNCTION is_prescription_valid(p_prescription_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  v_prescription prescriptions%ROWTYPE;
BEGIN
  SELECT * INTO v_prescription 
  FROM prescriptions 
  WHERE id = p_prescription_id;
  
  IF v_prescription IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Check status
  IF v_prescription.status != 'ACTIVE' THEN
    RETURN FALSE;
  END IF;
  
  -- Check expiry
  IF v_prescription.expiry_date < CURRENT_DATE THEN
    -- Auto-update status
    UPDATE prescriptions SET status = 'EXPIRED' WHERE id = p_prescription_id;
    RETURN FALSE;
  END IF;
  
  -- Check for controlled substances
  IF v_prescription.contains_controlled_substance THEN
    RETURN FALSE;  -- Cannot be used for delivery
  END IF;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Auto-expire prescriptions (run daily via cron)
CREATE OR REPLACE FUNCTION expire_old_prescriptions()
RETURNS INTEGER AS $$
DECLARE
  v_count INTEGER;
BEGIN
  UPDATE prescriptions 
  SET status = 'EXPIRED', updated_at = NOW()
  WHERE status = 'ACTIVE' 
    AND expiry_date < CURRENT_DATE;
    
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

---

## IMPLEMENTATION

### Image Processing Utilities

```typescript
// packages/services/src/prescription/image-processing.ts

import { createHash } from 'crypto';

interface ProcessedImage {
  blob: Blob;
  hash: string;
  width: number;
  height: number;
  mimeType: string;
}

/**
 * Process prescription image before upload
 * - Compress to reduce storage/bandwidth
 * - Calculate hash for deduplication
 * - Ensure reasonable dimensions
 */
export async function processPresriptionImage(file: File): Promise<ProcessedImage> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
      reject(new Error('Canvas context not available'));
      return;
    }

    img.onload = async () => {
      // Calculate new dimensions (max 2000px on longest side)
      const MAX_DIMENSION = 2000;
      let { width, height } = img;
      
      if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
        const ratio = Math.min(MAX_DIMENSION / width, MAX_DIMENSION / height);
        width = Math.round(width * ratio);
        height = Math.round(height * ratio);
      }

      canvas.width = width;
      canvas.height = height;

      // Draw and compress
      ctx.drawImage(img, 0, 0, width, height);
      
      canvas.toBlob(
        async (blob) => {
          if (!blob) {
            reject(new Error('Failed to compress image'));
            return;
          }

          // Calculate hash
          const arrayBuffer = await blob.arrayBuffer();
          const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
          const hashArray = Array.from(new Uint8Array(hashBuffer));
          const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

          resolve({
            blob,
            hash,
            width,
            height,
            mimeType: 'image/jpeg',
          });
        },
        'image/jpeg',
        0.85 // 85% quality - good balance of size/quality
      );
    };

    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
}
```

### Claude Vision Extraction Service

```typescript
// packages/services/src/prescription/extraction-service.ts

import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

// ═══════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════

export interface ExtractedPrescription {
  doctor: {
    name: string | null;
    specialty: string | null;
    registration: string | null;
    phone: string | null;
    address: string | null;
    confidence: number;
  };
  patient: {
    name: string | null;
    confidence: number;
  };
  prescriptionDate: string | null;  // ISO date
  medications: ExtractedMedication[];
  warnings: string[];
  overallConfidence: number;
}

export interface ExtractedMedication {
  rawText: string;              // Exactly as written
  medicationName: string;       // Cleaned/interpreted name
  dosage: string | null;
  quantity: number | null;
  frequency: string | null;
  duration: string | null;
  instructions: string | null;
  confidence: number;
  possibleControlledSubstance: boolean;
}

// ═══════════════════════════════════════════════════════════════
// EXTRACTION PROMPT
// ═══════════════════════════════════════════════════════════════

const EXTRACTION_PROMPT = `You are analyzing a Moroccan medical prescription (ordonnance). Extract all information into structured JSON.

CONTEXT:
- Moroccan prescriptions are often handwritten with poor legibility
- Text may be in French, Arabic, or mixed
- Common abbreviations: "Dolip" = Doliprane, "Amoxi" = Amoxicilline, "cp" = comprimé, "gél" = gélule
- "Numéro du Tableau" is the doctor's registration number with the Medical Council

CONTROLLED SUBSTANCES TO FLAG:
If you see any of these medications, set possibleControlledSubstance: true
- Tramadol, Tramal, Contramal, Topalgic
- Codéine, Néocodion, Paderyl
- Morphine, Moscontin, Skenan
- Diazépam, Valium
- Alprazolam, Xanax
- Lorazépam, Temesta
- Zolpidem, Stilnox
- Ritaline, Concerta, Méthylphénidate

OUTPUT FORMAT (JSON only, no markdown):
{
  "doctor": {
    "name": "string or null",
    "specialty": "string or null", 
    "registration": "string or null",
    "phone": "string or null",
    "address": "string or null",
    "confidence": 0.0-1.0
  },
  "patient": {
    "name": "string or null",
    "confidence": 0.0-1.0
  },
  "prescriptionDate": "YYYY-MM-DD or null",
  "medications": [
    {
      "rawText": "exactly as written",
      "medicationName": "interpreted medication name",
      "dosage": "string or null",
      "quantity": number or null,
      "frequency": "string or null",
      "duration": "string or null",
      "instructions": "string or null",
      "confidence": 0.0-1.0,
      "possibleControlledSubstance": boolean
    }
  ],
  "warnings": ["array of any concerns about this prescription"],
  "overallConfidence": 0.0-1.0
}

Be conservative with confidence scores:
- 0.9+ : Very clear, highly certain
- 0.7-0.9: Readable with some interpretation
- 0.5-0.7: Partially legible, some guessing
- <0.5: Mostly unreadable, low certainty`;

// ═══════════════════════════════════════════════════════════════
// EXTRACTION FUNCTION
// ═══════════════════════════════════════════════════════════════

export async function extractPrescriptionData(
  imageBase64: string,
  mimeType: string = 'image/jpeg'
): Promise<ExtractedPrescription> {
  try {
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'image',
              source: {
                type: 'base64',
                media_type: mimeType,
                data: imageBase64,
              },
            },
            {
              type: 'text',
              text: EXTRACTION_PROMPT,
            },
          ],
        },
      ],
    });

    // Extract JSON from response
    const textContent = response.content.find(c => c.type === 'text');
    if (!textContent || textContent.type !== 'text') {
      throw new Error('No text response from Claude');
    }

    // Parse JSON (Claude should return pure JSON)
    let jsonStr = textContent.text.trim();
    
    // Remove markdown code blocks if present
    if (jsonStr.startsWith('```')) {
      jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
    }

    const extracted: ExtractedPrescription = JSON.parse(jsonStr);
    
    return extracted;

  } catch (error) {
    console.error('[extractPrescriptionData] Error:', error);
    
    // Return empty structure with zero confidence
    return {
      doctor: {
        name: null,
        specialty: null,
        registration: null,
        phone: null,
        address: null,
        confidence: 0,
      },
      patient: {
        name: null,
        confidence: 0,
      },
      prescriptionDate: null,
      medications: [],
      warnings: ['Extraction failed - manual entry required'],
      overallConfidence: 0,
    };
  }
}
```

### Medication Matching Service

```typescript
// packages/services/src/prescription/medication-matcher.ts

import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

interface MedicationMatch {
  medicationId: string | null;
  medicationName: string;
  matchConfidence: number;
  matchMethod: 'exact' | 'fuzzy' | 'manual' | 'unmatched';
  isControlledSubstance: boolean;
}

/**
 * Match extracted medication text to our medication database
 * Uses progressive matching: exact → fuzzy → unmatched
 */
export async function matchMedication(
  extractedName: string,
  extractedDosage: string | null
): Promise<MedicationMatch> {
  const searchName = extractedName.toLowerCase().trim();
  
  // ═══════════════════════════════════════════════════════════
  // STEP 1: Check controlled substances first
  // ═══════════════════════════════════════════════════════════
  const { data: controlled } = await supabase
    .from('controlled_substances')
    .select('*')
    .or(`name.ilike.%${searchName}%,name_variants.cs.{${searchName}}`);
  
  if (controlled && controlled.length > 0) {
    return {
      medicationId: null,
      medicationName: extractedName,
      matchConfidence: 0.9,
      matchMethod: 'exact',
      isControlledSubstance: true,
    };
  }

  // ═══════════════════════════════════════════════════════════
  // STEP 2: Try exact match
  // ═══════════════════════════════════════════════════════════
  const exactQuery = extractedDosage 
    ? `name.ilike.%${searchName}%,dosage.ilike.%${extractedDosage}%`
    : `name.ilike.%${searchName}%`;
  
  const { data: exactMatches } = await supabase
    .from('medications')
    .select('id, name, dosage, form')
    .or(exactQuery)
    .limit(5);

  if (exactMatches && exactMatches.length === 1) {
    return {
      medicationId: exactMatches[0].id,
      medicationName: exactMatches[0].name,
      matchConfidence: 0.95,
      matchMethod: 'exact',
      isControlledSubstance: false,
    };
  }

  // ═══════════════════════════════════════════════════════════
  // STEP 3: Try fuzzy match using trigram similarity
  // ═══════════════════════════════════════════════════════════
  const { data: fuzzyMatches } = await supabase.rpc('search_medications_fuzzy', {
    search_term: searchName,
    similarity_threshold: 0.3,
    max_results: 5,
  });

  if (fuzzyMatches && fuzzyMatches.length > 0) {
    const bestMatch = fuzzyMatches[0];
    return {
      medicationId: bestMatch.id,
      medicationName: bestMatch.name,
      matchConfidence: bestMatch.similarity,
      matchMethod: 'fuzzy',
      isControlledSubstance: false,
    };
  }

  // ═══════════════════════════════════════════════════════════
  // STEP 4: No match found
  // ═══════════════════════════════════════════════════════════
  return {
    medicationId: null,
    medicationName: extractedName,
    matchConfidence: 0,
    matchMethod: 'unmatched',
    isControlledSubstance: false,
  };
}

// SQL function for fuzzy search (create in Supabase)
/*
CREATE EXTENSION IF NOT EXISTS pg_trgm;

CREATE OR REPLACE FUNCTION search_medications_fuzzy(
  search_term TEXT,
  similarity_threshold REAL DEFAULT 0.3,
  max_results INTEGER DEFAULT 10
)
RETURNS TABLE (
  id UUID,
  name TEXT,
  dosage TEXT,
  similarity REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    m.id,
    m.name,
    m.dosage,
    similarity(LOWER(m.name), LOWER(search_term)) as sim
  FROM medications m
  WHERE similarity(LOWER(m.name), LOWER(search_term)) > similarity_threshold
  ORDER BY sim DESC
  LIMIT max_results;
END;
$$ LANGUAGE plpgsql;
*/
```

### Prescription Upload Hook

```typescript
// apps/patient/src/hooks/usePrescriptionUpload.ts

import { useState, useCallback } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { getSupabaseClient } from '@/lib/supabase/client';
import { processPresriptionImage } from '@/lib/prescription/image-processing';

type UploadStatus = 
  | 'idle'
  | 'processing'    // Compressing image
  | 'uploading'     // Uploading to storage
  | 'extracting'    // Claude is analyzing
  | 'matching'      // Matching medications
  | 'review'        // Needs user review
  | 'complete'      // All done
  | 'error';

interface UsePrescriptionUploadOptions {
  onComplete?: (prescriptionId: string) => void;
  onControlledSubstance?: (substances: string[]) => void;
}

export function usePrescriptionUpload(options: UsePrescriptionUploadOptions = {}) {
  const [status, setStatus] = useState<UploadStatus>('idle');
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  
  const supabase = getSupabaseClient();
  const queryClient = useQueryClient();

  const upload = useCallback(async (file: File) => {
    setStatus('processing');
    setProgress(10);
    setError(null);

    try {
      // ═══════════════════════════════════════════════════════
      // STEP 1: Process image (compress + hash)
      // ═══════════════════════════════════════════════════════
      const processed = await processPresriptionImage(file);
      setProgress(20);

      // ═══════════════════════════════════════════════════════
      // STEP 2: Check for duplicate
      // ═══════════════════════════════════════════════════════
      const { data: existing } = await supabase
        .from('prescriptions')
        .select('id')
        .eq('image_hash', processed.hash)
        .single();

      if (existing) {
        setStatus('complete');
        setProgress(100);
        options.onComplete?.(existing.id);
        return { prescriptionId: existing.id, isDuplicate: true };
      }

      // ═══════════════════════════════════════════════════════
      // STEP 3: Upload to Supabase Storage
      // ═══════════════════════════════════════════════════════
      setStatus('uploading');
      setProgress(30);

      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const fileName = `${user.id}/${processed.hash}.jpg`;
      const { error: uploadError } = await supabase.storage
        .from('prescriptions')
        .upload(fileName, processed.blob, {
          contentType: 'image/jpeg',
          upsert: true,
        });

      if (uploadError) throw uploadError;

      const { data: { publicUrl } } = supabase.storage
        .from('prescriptions')
        .getPublicUrl(fileName);

      setProgress(50);

      // ═══════════════════════════════════════════════════════
      // STEP 4: Create prescription record
      // ═══════════════════════════════════════════════════════
      const { data: prescription, error: insertError } = await supabase
        .from('prescriptions')
        .insert({
          patient_id: user.id,
          image_url: publicUrl,
          image_hash: processed.hash,
          extraction_status: 'PROCESSING',
        })
        .select()
        .single();

      if (insertError) throw insertError;

      // ═══════════════════════════════════════════════════════
      // STEP 5: Extract via Claude Vision (server-side)
      // ═══════════════════════════════════════════════════════
      setStatus('extracting');
      setProgress(60);

      const { data: extractionResult, error: extractionError } = await supabase
        .functions.invoke('extract-prescription', {
          body: { prescriptionId: prescription.id },
        });

      if (extractionError) throw extractionError;

      setProgress(80);

      // ═══════════════════════════════════════════════════════
      // STEP 6: Check for controlled substances
      // ═══════════════════════════════════════════════════════
      if (extractionResult.containsControlledSubstance) {
        setStatus('error');
        setError('Cette ordonnance contient des substances contrôlées qui ne peuvent pas être livrées.');
        options.onControlledSubstance?.(extractionResult.controlledSubstances);
        return { prescriptionId: prescription.id, blocked: true };
      }

      // ═══════════════════════════════════════════════════════
      // STEP 7: Check if needs review
      // ═══════════════════════════════════════════════════════
      if (extractionResult.needsReview) {
        setStatus('review');
        setProgress(90);
        return { prescriptionId: prescription.id, needsReview: true };
      }

      // ═══════════════════════════════════════════════════════
      // STEP 8: Complete!
      // ═══════════════════════════════════════════════════════
      setStatus('complete');
      setProgress(100);
      
      queryClient.invalidateQueries({ queryKey: ['prescriptions'] });
      options.onComplete?.(prescription.id);
      
      return { prescriptionId: prescription.id };

    } catch (err) {
      console.error('[usePrescriptionUpload] Error:', err);
      setStatus('error');
      setError(err instanceof Error ? err.message : 'Upload failed');
      throw err;
    }
  }, [supabase, queryClient, options]);

  const reset = useCallback(() => {
    setStatus('idle');
    setProgress(0);
    setError(null);
  }, []);

  return {
    upload,
    reset,
    status,
    progress,
    error,
    isProcessing: ['processing', 'uploading', 'extracting', 'matching'].includes(status),
  };
}
```

### Prescription Upload Component

```typescript
// apps/patient/src/components/features/prescriptions/prescription-upload.tsx

'use client';

import { useState, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Upload, Camera, FileText, AlertTriangle, Check, 
  X, Loader2, Image as ImageIcon, Edit3 
} from 'lucide-react';
import { useDropzone } from 'react-dropzone';

import { usePrescriptionUpload } from '@/hooks/usePrescriptionUpload';
import { cn } from '@/lib/utils';

interface PrescriptionUploadProps {
  onComplete: (prescriptionId: string) => void;
  onCancel: () => void;
}

export function PrescriptionUpload({ onComplete, onCancel }: PrescriptionUploadProps) {
  const [preview, setPreview] = useState<string | null>(null);
  const [showControlledWarning, setShowControlledWarning] = useState(false);
  const [controlledSubstances, setControlledSubstances] = useState<string[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const {
    upload,
    reset,
    status,
    progress,
    error,
    isProcessing,
  } = usePrescriptionUpload({
    onComplete,
    onControlledSubstance: (substances) => {
      setControlledSubstances(substances);
      setShowControlledWarning(true);
    },
  });

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    if (!file) return;

    // Show preview
    const previewUrl = URL.createObjectURL(file);
    setPreview(previewUrl);

    // Start upload
    await upload(file);
  }, [upload]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png', '.heic'],
    },
    maxFiles: 1,
    disabled: isProcessing,
  });

  const handleCameraCapture = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  const handleRetry = () => {
    setPreview(null);
    setShowControlledWarning(false);
    setControlledSubstances([]);
    reset();
  };

  // ═══════════════════════════════════════════════════════════
  // CONTROLLED SUBSTANCE WARNING
  // ═══════════════════════════════════════════════════════════
  if (showControlledWarning) {
    return (
      <div className="rounded-2xl bg-red-50 border-2 border-red-200 p-6">
        <div className="flex items-start gap-4">
          <div className="flex h-12 w-12 shrink-0 items-center justify-center rounded-full bg-red-100">
            <AlertTriangle className="h-6 w-6 text-red-600" />
          </div>
          <div className="flex-1">
            <h3 className="font-semibold text-red-800 text-lg">
              Livraison non disponible
            </h3>
            <p className="text-red-700 mt-1">
              Cette ordonnance contient des substances contrôlées qui ne peuvent pas être livrées selon la réglementation marocaine.
            </p>
            <div className="mt-3 bg-red-100 rounded-lg p-3">
              <p className="text-sm font-medium text-red-800">Médicaments détectés:</p>
              <ul className="mt-1 text-sm text-red-700">
                {controlledSubstances.map((substance, i) => (
                  <li key={i}>• {substance}</li>
                ))}
              </ul>
            </div>
            <p className="text-sm text-red-600 mt-3">
              Veuillez vous rendre en pharmacie avec l'ordonnance originale pour ces médicaments.
            </p>
            <div className="flex gap-3 mt-4">
              <button
                onClick={onCancel}
                className="flex-1 rounded-xl border border-red-300 py-2.5 text-red-700 font-medium hover:bg-red-100"
              >
                Fermer
              </button>
              <button
                onClick={handleRetry}
                className="flex-1 rounded-xl bg-red-600 py-2.5 text-white font-medium hover:bg-red-700"
              >
                Autre ordonnance
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // ═══════════════════════════════════════════════════════════
  // PROCESSING STATE
  // ═══════════════════════════════════════════════════════════
  if (isProcessing) {
    return (
      <div className="rounded-2xl border-2 border-primary-200 bg-primary-50 p-6">
        <div className="flex flex-col items-center">
          {/* Preview */}
          {preview && (
            <div className="relative w-full max-w-sm mb-6 rounded-xl overflow-hidden shadow-lg">
              <img src={preview} alt="Ordonnance" className="w-full" />
              <div className="absolute inset-0 bg-black/40 flex items-center justify-center">
                <Loader2 className="h-10 w-10 text-white animate-spin" />
              </div>
            </div>
          )}

          {/* Progress */}
          <div className="w-full max-w-xs">
            <div className="flex justify-between text-sm mb-2">
              <span className="text-primary-700 font-medium">
                {status === 'processing' && 'Traitement de l\'image...'}
                {status === 'uploading' && 'Téléchargement...'}
                {status === 'extracting' && 'Analyse en cours...'}
                {status === 'matching' && 'Identification des médicaments...'}
              </span>
              <span className="text-primary-600">{progress}%</span>
            </div>
            <div className="h-2 bg-primary-200 rounded-full overflow-hidden">
              <motion.div
                className="h-full bg-primary-500"
                initial={{ width: 0 }}
                animate={{ width: `${progress}%` }}
                transition={{ duration: 0.3 }}
              />
            </div>
          </div>
        </div>
      </div>
    );
  }

  // ═══════════════════════════════════════════════════════════
  // ERROR STATE
  // ═══════════════════════════════════════════════════════════
  if (status === 'error' && error) {
    return (
      <div className="rounded-2xl border-2 border-red-200 bg-red-50 p-6 text-center">
        <div className="flex flex-col items-center">
          <div className="h-12 w-12 rounded-full bg-red-100 flex items-center justify-center mb-4">
            <X className="h-6 w-6 text-red-600" />
          </div>
          <h3 className="font-semibold text-red-800">Erreur</h3>
          <p className="text-red-700 mt-1">{error}</p>
          <button
            onClick={handleRetry}
            className="mt-4 rounded-xl bg-red-600 px-6 py-2.5 text-white font-medium hover:bg-red-700"
          >
            Réessayer
          </button>
        </div>
      </div>
    );
  }

  // ═══════════════════════════════════════════════════════════
  // REVIEW STATE
  // ═══════════════════════════════════════════════════════════
  if (status === 'review') {
    return (
      <div className="rounded-2xl border-2 border-yellow-200 bg-yellow-50 p-6">
        <div className="flex items-start gap-4">
          <div className="flex h-10 w-10 shrink-0 items-center justify-center rounded-full bg-yellow-100">
            <Edit3 className="h-5 w-5 text-yellow-600" />
          </div>
          <div className="flex-1">
            <h3 className="font-semibold text-yellow-800">Vérification requise</h3>
            <p className="text-yellow-700 text-sm mt-1">
              Certains éléments n'ont pas pu être lus automatiquement. Veuillez vérifier et compléter les informations.
            </p>
            <button
              onClick={() => onComplete(/* prescriptionId */)}
              className="mt-4 w-full rounded-xl bg-yellow-600 py-2.5 text-white font-medium hover:bg-yellow-700"
            >
              Vérifier et continuer
            </button>
          </div>
        </div>
      </div>
    );
  }

  // ═══════════════════════════════════════════════════════════
  // DEFAULT: UPLOAD STATE
  // ═══════════════════════════════════════════════════════════
  return (
    <div className="space-y-4">
      {/* Dropzone */}
      <div
        {...getRootProps()}
        className={cn(
          'relative rounded-2xl border-2 border-dashed p-8 transition-colors cursor-pointer',
          isDragActive 
            ? 'border-primary-500 bg-primary-50' 
            : 'border-gray-300 hover:border-primary-400 hover:bg-gray-50'
        )}
      >
        <input {...getInputProps()} />
        
        <div className="flex flex-col items-center text-center">
          <div className={cn(
            'h-16 w-16 rounded-full flex items-center justify-center mb-4',
            isDragActive ? 'bg-primary-100' : 'bg-gray-100'
          )}>
            <Upload className={cn(
              'h-8 w-8',
              isDragActive ? 'text-primary-600' : 'text-gray-400'
            )} />
          </div>
          
          <h3 className="font-semibold text-gray-900">
            {isDragActive ? 'Déposez l\'image ici' : 'Téléchargez votre ordonnance'}
          </h3>
          <p className="text-gray-500 text-sm mt-1">
            Glissez-déposez ou cliquez pour sélectionner
          </p>
          <p className="text-gray-400 text-xs mt-2">
            JPG, PNG ou HEIC • Max 10 MB
          </p>
        </div>
      </div>

      {/* Camera button (mobile) */}
      <div className="sm:hidden">
        <input
          ref={fileInputRef}
          type="file"
          accept="image/*"
          capture="environment"
          className="hidden"
          onChange={(e) => {
            const file = e.target.files?.[0];
            if (file) onDrop([file]);
          }}
        />
        <button
          onClick={handleCameraCapture}
          className="w-full flex items-center justify-center gap-2 rounded-xl border-2 border-gray-300 py-3 text-gray-700 font-medium hover:bg-gray-50"
        >
          <Camera className="h-5 w-5" />
          Prendre une photo
        </button>
      </div>

      {/* Help text */}
      <div className="rounded-xl bg-blue-50 p-4">
        <div className="flex gap-3">
          <FileText className="h-5 w-5 text-blue-600 shrink-0 mt-0.5" />
          <div className="text-sm text-blue-800">
            <p className="font-medium">Conseils pour une bonne photo:</p>
            <ul className="mt-1 space-y-0.5 text-blue-700">
              <li>• Placez l'ordonnance sur une surface plate</li>
              <li>• Assurez-vous d'un bon éclairage</li>
              <li>• Incluez toute l'ordonnance dans le cadre</li>
              <li>• Évitez les reflets et les ombres</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
}
```

---

## SUCCESS CRITERIA

- [ ] Image processing with compression and SHA-256 hashing
- [ ] Duplicate detection prevents re-uploading same prescription
- [ ] Claude Vision extraction with structured JSON output
- [ ] Medication matching with exact → fuzzy → unmatched flow
- [ ] Controlled substance detection and blocking
- [ ] Prescription expiry calculation (date + 30 days)
- [ ] Manual entry fallback for low-confidence extractions
- [ ] User review flow for partially extracted data
- [ ] Progress states during upload/extraction
- [ ] Clear error messages for all failure modes
- [ ] Mobile camera capture support
- [ ] Drag-and-drop desktop support

---

## NEXT STEP

After validation passes, proceed to:
→ `dawa-docs/prompts/phase-1/P1.10-profile-settings.md`

Reference documentation:
→ `dawa-docs/docs/DAWA_MASTER.md`
→ `dawa-docs/docs/phases/PHASE_1.md`
