# P1.11 â€” Chat System (V100)

## Prompt ID: P1.11
## Phase: 1 - Patient Web App
## Estimated Time: 8-10 hours
## Prerequisites: P1.10 complete

---

## STRATEGIC CONTEXT

### Why Chat Matters in Medication Delivery

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CHAT USE CASES                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  PATIENT â†” PHARMACY:                                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  â€¢ "Is the generic version available instead?"                              â”‚
â”‚  â€¢ "Can you substitute Brand X for Brand Y?"                               â”‚
â”‚  â€¢ "I need urgent clarification on this prescription"                      â”‚
â”‚  â€¢ "The dosage on the prescription is unclear"                             â”‚
â”‚  â€¢ "Can I pick up instead of delivery?"                                    â”‚
â”‚                                                                              â”‚
â”‚  PATIENT â†” COURIER:                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  â€¢ "I'm at the blue door, not the main entrance"                          â”‚
â”‚  â€¢ "Can you call when you arrive? I'm on 3rd floor"                       â”‚
â”‚  â€¢ "I'll be 5 minutes late, please wait"                                   â”‚
â”‚  â€¢ "Wrong building - it's the one across the street"                      â”‚
â”‚                                                                              â”‚
â”‚  SYSTEM MESSAGES (automated):                                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  â€¢ "Your order has been confirmed"                                         â”‚
â”‚  â€¢ "Courier is 5 minutes away"                                             â”‚
â”‚  â€¢ "Delivery completed. Rate your experience?"                            â”‚
â”‚                                                                              â”‚
â”‚  CRITICAL INSIGHT:                                                          â”‚
â”‚  Most messages are URGENT and TIME-SENSITIVE during active orders.        â”‚
â”‚  Must have near-instant delivery and read receipts.                       â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## DATA MODEL

```sql
-- ============================================================
-- CHAT SYSTEM SCHEMA
-- ============================================================

-- Chat conversations (one per order, per participant pair)
CREATE TABLE chat_conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  
  -- Participants
  participant_1_id UUID NOT NULL REFERENCES users(id),
  participant_1_type TEXT NOT NULL, -- 'patient', 'pharmacy', 'courier'
  participant_2_id UUID NOT NULL REFERENCES users(id),
  participant_2_type TEXT NOT NULL,
  
  -- Metadata
  last_message_at TIMESTAMPTZ,
  last_message_preview TEXT,
  
  -- Status
  status TEXT DEFAULT 'ACTIVE', -- ACTIVE, ARCHIVED, CLOSED
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Ensure unique conversation per order per pair
  UNIQUE(order_id, participant_1_id, participant_2_id)
);

CREATE INDEX idx_conversations_participant_1 ON chat_conversations(participant_1_id, status);
CREATE INDEX idx_conversations_participant_2 ON chat_conversations(participant_2_id, status);
CREATE INDEX idx_conversations_order ON chat_conversations(order_id);

-- Chat messages
CREATE TABLE chat_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES chat_conversations(id) ON DELETE CASCADE,
  
  -- Sender
  sender_id UUID NOT NULL REFERENCES users(id),
  sender_type TEXT NOT NULL,
  
  -- Content
  content TEXT NOT NULL,
  message_type TEXT DEFAULT 'TEXT', -- TEXT, IMAGE, SYSTEM, LOCATION
  metadata JSONB, -- For images: { url, thumbnail_url, width, height }
  
  -- Status
  status TEXT DEFAULT 'SENT', -- SENT, DELIVERED, READ
  delivered_at TIMESTAMPTZ,
  read_at TIMESTAMPTZ,
  
  -- For system messages
  is_system_message BOOLEAN DEFAULT false,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_messages_conversation ON chat_messages(conversation_id, created_at DESC);
CREATE INDEX idx_messages_unread ON chat_messages(conversation_id, status) WHERE status != 'READ';

-- Enable real-time
ALTER PUBLICATION supabase_realtime ADD TABLE chat_messages;

-- Unread count function
CREATE OR REPLACE FUNCTION get_unread_count(p_user_id UUID)
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM chat_messages m
    JOIN chat_conversations c ON m.conversation_id = c.id
    WHERE (c.participant_1_id = p_user_id OR c.participant_2_id = p_user_id)
      AND m.sender_id != p_user_id
      AND m.status != 'READ'
  );
END;
$$ LANGUAGE plpgsql;

-- Trigger to update conversation last_message
CREATE OR REPLACE FUNCTION update_conversation_last_message()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE chat_conversations
  SET 
    last_message_at = NEW.created_at,
    last_message_preview = LEFT(NEW.content, 100)
  WHERE id = NEW.conversation_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_conversation_last_message
  AFTER INSERT ON chat_messages
  FOR EACH ROW
  EXECUTE FUNCTION update_conversation_last_message();
```

---

## IMPLEMENTATION

### Step 1: Chat Service

Create `apps/patient/src/services/chat-service.ts`:

```typescript
// ============================================================
// Chat Service
// Real-time messaging with Supabase
// ============================================================

import { RealtimeChannel } from '@supabase/supabase-js';
import { getSupabaseClient } from '@/lib/supabase/client';

export interface ChatMessage {
  id: string;
  conversationId: string;
  senderId: string;
  senderType: 'patient' | 'pharmacy' | 'courier';
  content: string;
  messageType: 'TEXT' | 'IMAGE' | 'SYSTEM' | 'LOCATION';
  metadata?: Record<string, any>;
  status: 'SENT' | 'DELIVERED' | 'READ';
  isSystemMessage: boolean;
  createdAt: string;
}

export interface ChatConversation {
  id: string;
  orderId: string;
  participantType: 'pharmacy' | 'courier';
  participantName: string;
  participantPhoto?: string;
  lastMessage?: string;
  lastMessageAt?: string;
  unreadCount: number;
}

class ChatService {
  private supabase = getSupabaseClient();
  private channels: Map<string, RealtimeChannel> = new Map();
  private messageCallbacks: Map<string, (message: ChatMessage) => void> = new Map();

  // Get or create conversation for an order
  async getOrCreateConversation(
    orderId: string,
    participantType: 'pharmacy' | 'courier'
  ): Promise<string> {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    // Get order to find participant
    const { data: order } = await this.supabase
      .from('orders')
      .select('pharmacy_id, courier_id')
      .eq('id', orderId)
      .single();

    if (!order) throw new Error('Order not found');

    const participantId = participantType === 'pharmacy' 
      ? order.pharmacy_id 
      : order.courier_id;

    if (!participantId) {
      throw new Error(`No ${participantType} assigned to this order`);
    }

    // Check for existing conversation
    const { data: existing } = await this.supabase
      .from('chat_conversations')
      .select('id')
      .eq('order_id', orderId)
      .or(`participant_1_id.eq.${user.id},participant_2_id.eq.${user.id}`)
      .or(`participant_1_id.eq.${participantId},participant_2_id.eq.${participantId}`)
      .single();

    if (existing) return existing.id;

    // Create new conversation
    const { data: created, error } = await this.supabase
      .from('chat_conversations')
      .insert({
        order_id: orderId,
        participant_1_id: user.id,
        participant_1_type: 'patient',
        participant_2_id: participantId,
        participant_2_type: participantType,
      })
      .select('id')
      .single();

    if (error) throw error;
    return created.id;
  }

  // Get conversations for current user
  async getConversations(): Promise<ChatConversation[]> {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) return [];

    const { data, error } = await this.supabase
      .from('chat_conversations')
      .select(`
        id,
        order_id,
        participant_1_id,
        participant_1_type,
        participant_2_id,
        participant_2_type,
        last_message_at,
        last_message_preview,
        order:orders(
          order_number,
          pharmacy:pharmacies(name, logo_url),
          courier:couriers(full_name, photo_url)
        )
      `)
      .or(`participant_1_id.eq.${user.id},participant_2_id.eq.${user.id}`)
      .eq('status', 'ACTIVE')
      .order('last_message_at', { ascending: false });

    if (error || !data) return [];

    // Get unread counts
    const { data: unreadData } = await this.supabase
      .from('chat_messages')
      .select('conversation_id')
      .in('conversation_id', data.map(c => c.id))
      .neq('sender_id', user.id)
      .neq('status', 'READ');

    const unreadCounts = new Map<string, number>();
    unreadData?.forEach(m => {
      unreadCounts.set(m.conversation_id, (unreadCounts.get(m.conversation_id) || 0) + 1);
    });

    return data.map(conv => {
      const isParticipant1 = conv.participant_1_id === user.id;
      const otherType = isParticipant1 ? conv.participant_2_type : conv.participant_1_type;
      
      return {
        id: conv.id,
        orderId: conv.order_id,
        participantType: otherType as 'pharmacy' | 'courier',
        participantName: otherType === 'pharmacy' 
          ? (conv.order as any)?.pharmacy?.name || 'Pharmacie'
          : (conv.order as any)?.courier?.full_name || 'Livreur',
        participantPhoto: otherType === 'pharmacy'
          ? (conv.order as any)?.pharmacy?.logo_url
          : (conv.order as any)?.courier?.photo_url,
        lastMessage: conv.last_message_preview,
        lastMessageAt: conv.last_message_at,
        unreadCount: unreadCounts.get(conv.id) || 0,
      };
    });
  }

  // Get messages for a conversation
  async getMessages(conversationId: string, limit = 50): Promise<ChatMessage[]> {
    const { data, error } = await this.supabase
      .from('chat_messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) throw error;

    return (data || []).reverse().map(this.mapMessage);
  }

  // Send a message
  async sendMessage(
    conversationId: string,
    content: string,
    type: 'TEXT' | 'IMAGE' | 'LOCATION' = 'TEXT',
    metadata?: Record<string, any>
  ): Promise<ChatMessage> {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    // Get user type
    const { data: patient } = await this.supabase
      .from('patients')
      .select('id')
      .eq('user_id', user.id)
      .single();

    const senderType = patient ? 'patient' : 'unknown';

    const { data, error } = await this.supabase
      .from('chat_messages')
      .insert({
        conversation_id: conversationId,
        sender_id: user.id,
        sender_type: senderType,
        content,
        message_type: type,
        metadata,
      })
      .select()
      .single();

    if (error) throw error;
    return this.mapMessage(data);
  }

  // Mark messages as read
  async markAsRead(conversationId: string): Promise<void> {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) return;

    await this.supabase
      .from('chat_messages')
      .update({ status: 'READ', read_at: new Date().toISOString() })
      .eq('conversation_id', conversationId)
      .neq('sender_id', user.id)
      .neq('status', 'READ');
  }

  // Subscribe to new messages
  subscribeToMessages(
    conversationId: string,
    callback: (message: ChatMessage) => void
  ): () => void {
    const channel = this.supabase
      .channel(`chat:${conversationId}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'chat_messages',
          filter: `conversation_id=eq.${conversationId}`,
        },
        (payload) => {
          callback(this.mapMessage(payload.new));
        }
      )
      .subscribe();

    this.channels.set(conversationId, channel);
    this.messageCallbacks.set(conversationId, callback);

    return () => {
      this.supabase.removeChannel(channel);
      this.channels.delete(conversationId);
      this.messageCallbacks.delete(conversationId);
    };
  }

  private mapMessage(data: any): ChatMessage {
    return {
      id: data.id,
      conversationId: data.conversation_id,
      senderId: data.sender_id,
      senderType: data.sender_type,
      content: data.content,
      messageType: data.message_type,
      metadata: data.metadata,
      status: data.status,
      isSystemMessage: data.is_system_message,
      createdAt: data.created_at,
    };
  }
}

export const chatService = new ChatService();
```

### Step 2: Chat Hook

Create `apps/patient/src/hooks/useChat.ts`:

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { chatService, ChatMessage, ChatConversation } from '@/services/chat-service';
import { useAuth } from '@/hooks/useAuth';

interface UseChatOptions {
  conversationId: string;
  autoMarkRead?: boolean;
}

export function useChat({ conversationId, autoMarkRead = true }: UseChatOptions) {
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSending, setIsSending] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const unsubscribeRef = useRef<(() => void) | null>(null);

  // Load initial messages
  useEffect(() => {
    async function loadMessages() {
      setIsLoading(true);
      try {
        const data = await chatService.getMessages(conversationId);
        setMessages(data);
        if (autoMarkRead) {
          await chatService.markAsRead(conversationId);
        }
      } catch (err) {
        setError(err as Error);
      } finally {
        setIsLoading(false);
      }
    }
    loadMessages();
  }, [conversationId, autoMarkRead]);

  // Subscribe to new messages
  useEffect(() => {
    const unsubscribe = chatService.subscribeToMessages(conversationId, (newMessage) => {
      setMessages(prev => [...prev, newMessage]);
      if (autoMarkRead && newMessage.senderId !== user?.id) {
        chatService.markAsRead(conversationId);
      }
      // Invalidate conversations list
      queryClient.invalidateQueries({ queryKey: ['conversations'] });
    });

    unsubscribeRef.current = unsubscribe;

    return () => {
      unsubscribe();
    };
  }, [conversationId, user?.id, autoMarkRead, queryClient]);

  // Send message
  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim()) return;

    setIsSending(true);
    try {
      const message = await chatService.sendMessage(conversationId, content);
      setMessages(prev => [...prev, message]);
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setIsSending(false);
    }
  }, [conversationId]);

  // Send image
  const sendImage = useCallback(async (imageUrl: string, metadata?: { width: number; height: number }) => {
    setIsSending(true);
    try {
      const message = await chatService.sendMessage(
        conversationId, 
        'ğŸ“· Image', 
        'IMAGE', 
        { url: imageUrl, ...metadata }
      );
      setMessages(prev => [...prev, message]);
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setIsSending(false);
    }
  }, [conversationId]);

  return {
    messages,
    isLoading,
    isSending,
    error,
    sendMessage,
    sendImage,
  };
}

// Hook for conversation list
export function useConversations() {
  const [conversations, setConversations] = useState<ChatConversation[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function load() {
      try {
        const data = await chatService.getConversations();
        setConversations(data);
      } finally {
        setIsLoading(false);
      }
    }
    load();
  }, []);

  const totalUnread = conversations.reduce((sum, c) => sum + c.unreadCount, 0);

  return { conversations, isLoading, totalUnread };
}
```

### Step 3: Chat UI Component

Create `apps/patient/src/components/features/chat/chat-view.tsx`:

```typescript
'use client';

import { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ArrowLeft, Send, Image as ImageIcon, Loader2 } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';
import { fr } from 'date-fns/locale';

import { useChat } from '@/hooks/useChat';
import { useAuth } from '@/hooks/useAuth';
import type { ChatMessage } from '@/services/chat-service';

interface ChatViewProps {
  conversationId: string;
  participantName: string;
  participantPhoto?: string;
  participantType: 'pharmacy' | 'courier';
  onBack: () => void;
}

export function ChatView({
  conversationId,
  participantName,
  participantPhoto,
  participantType,
  onBack,
}: ChatViewProps) {
  const { user } = useAuth();
  const { messages, isLoading, isSending, sendMessage } = useChat({ conversationId });
  const [inputValue, setInputValue] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Auto-scroll to bottom
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Handle send
  const handleSend = async () => {
    if (!inputValue.trim() || isSending) return;
    const message = inputValue;
    setInputValue('');
    try {
      await sendMessage(message);
    } catch {
      setInputValue(message); // Restore on error
    }
  };

  return (
    <div className="flex flex-col h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white border-b border-gray-100 px-4 py-3 flex items-center gap-3">
        <button onClick={onBack} className="p-1 -ml-1">
          <ArrowLeft className="h-5 w-5" />
        </button>
        
        <div className="h-10 w-10 rounded-full overflow-hidden bg-gray-200">
          {participantPhoto ? (
            <img src={participantPhoto} alt="" className="h-full w-full object-cover" />
          ) : (
            <div className="h-full w-full flex items-center justify-center bg-primary-100">
              <span className="text-primary-600 font-medium">
                {participantName[0]}
              </span>
            </div>
          )}
        </div>
        
        <div className="flex-1">
          <h2 className="font-semibold text-gray-900">{participantName}</h2>
          <p className="text-xs text-gray-500">
            {participantType === 'pharmacy' ? 'Pharmacie' : 'Livreur'}
          </p>
        </div>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-3">
        {isLoading ? (
          <div className="flex justify-center py-8">
            <Loader2 className="h-6 w-6 animate-spin text-gray-400" />
          </div>
        ) : messages.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            <p>DÃ©marrez la conversation</p>
          </div>
        ) : (
          messages.map((message, index) => (
            <MessageBubble
              key={message.id}
              message={message}
              isOwn={message.senderId === user?.id}
              showTimestamp={
                index === 0 ||
                new Date(message.createdAt).getTime() - 
                new Date(messages[index - 1].createdAt).getTime() > 300000
              }
            />
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <div className="bg-white border-t border-gray-100 p-4">
        <div className="flex items-center gap-2">
          <input
            ref={inputRef}
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyDown={(e) => e.key === 'Enter' && handleSend()}
            placeholder="Votre message..."
            className="flex-1 rounded-full border border-gray-200 px-4 py-2.5 focus:border-primary-500 focus:outline-none focus:ring-2 focus:ring-primary-500/20"
          />
          <button
            onClick={handleSend}
            disabled={!inputValue.trim() || isSending}
            className="flex h-10 w-10 items-center justify-center rounded-full bg-primary-500 text-white disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSending ? (
              <Loader2 className="h-5 w-5 animate-spin" />
            ) : (
              <Send className="h-5 w-5" />
            )}
          </button>
        </div>
      </div>
    </div>
  );
}

function MessageBubble({ 
  message, 
  isOwn, 
  showTimestamp 
}: { 
  message: ChatMessage; 
  isOwn: boolean; 
  showTimestamp: boolean;
}) {
  return (
    <div className={`flex ${isOwn ? 'justify-end' : 'justify-start'}`}>
      <div className={`max-w-[75%] ${isOwn ? 'items-end' : 'items-start'}`}>
        {showTimestamp && (
          <p className="text-xs text-gray-400 mb-1 px-2">
            {formatDistanceToNow(new Date(message.createdAt), { 
              addSuffix: true, 
              locale: fr 
            })}
          </p>
        )}
        <div
          className={`
            rounded-2xl px-4 py-2.5
            ${message.isSystemMessage
              ? 'bg-gray-100 text-gray-600 text-sm italic'
              : isOwn
              ? 'bg-primary-500 text-white'
              : 'bg-white border border-gray-200 text-gray-900'
            }
          `}
        >
          {message.messageType === 'IMAGE' && message.metadata?.url ? (
            <img
              src={message.metadata.url}
              alt="Image"
              className="rounded-lg max-w-full max-h-48 object-cover"
            />
          ) : (
            <p className="break-words">{message.content}</p>
          )}
        </div>
        {isOwn && !message.isSystemMessage && (
          <p className="text-xs text-gray-400 mt-0.5 px-2">
            {message.status === 'READ' ? 'Lu' : message.status === 'DELIVERED' ? 'EnvoyÃ©' : '...'}
          </p>
        )}
      </div>
    </div>
  );
}
```

---

## SUCCESS CRITERIA

- [ ] Real-time message delivery via Supabase Realtime
- [ ] Conversation management (patient â†” pharmacy, patient â†” courier)
- [ ] Message status tracking (sent, delivered, read)
- [ ] Unread count badges
- [ ] Auto-scroll to latest messages
- [ ] System message styling
- [ ] Image message support
- [ ] Typing indicator (stretch goal)

---

## NEXT STEP

After validation passes, proceed to:
â†’ `dawa-docs/prompts/phase-1/P1.12-notifications.md`

Reference documentation:
â†’ `dawa-docs/docs/DAWA_MASTER.md`
â†’ `dawa-docs/docs/phases/PHASE_1.md`
