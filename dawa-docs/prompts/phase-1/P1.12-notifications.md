# P1.12 — Notifications System (V100)

## Prompt ID: P1.12
## Phase: 1 - Patient Web App
## Estimated Time: 10-12 hours
## Prerequisites: P1.11 complete

---

## STRATEGIC CONTEXT

### The Real Problem

Notifications aren't just alerts—they're the **primary communication channel** between DAWA and the patient during the critical order fulfillment window. Get them wrong, and patients miss deliveries, worry unnecessarily, or get annoyed and disable them entirely.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    NOTIFICATION FAILURE SCENARIOS                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SCENARIO 1: TOO MANY NOTIFICATIONS (Spam)                                  │
│  ─────────────────────────────────────────────────────────────────────────   │
│  What happens:                                                              │
│  • Patient receives 10+ notifications per order                            │
│  • "Order received" "Order confirmed" "Preparing" "Ready" "Assigned"...   │
│  • Patient disables notifications entirely                                 │
│                                                                              │
│  Consequence:                                                               │
│  • Misses "Courier arriving" notification                                  │
│  • Not home when courier arrives                                           │
│  • Delivery fails → patient angry → pharmacy loses time → courier loses $  │
│                                                                              │
│  SCENARIO 2: TOO FEW NOTIFICATIONS (Anxiety)                               │
│  ─────────────────────────────────────────────────────────────────────────   │
│  What happens:                                                              │
│  • Patient orders medication for sick child                                │
│  • No updates for 45 minutes                                               │
│  • Patient panics: "Did they get my order? Is something wrong?"           │
│  • Patient calls pharmacy 3 times, opens app 10 times                     │
│                                                                              │
│  Consequence:                                                               │
│  • Support burden on pharmacy                                              │
│  • Negative experience despite successful delivery                        │
│                                                                              │
│  SCENARIO 3: WRONG CHANNEL (Missed Critical)                               │
│  ─────────────────────────────────────────────────────────────────────────   │
│  What happens:                                                              │
│  • Courier arrives, only in-app notification sent                         │
│  • Patient's phone is in pocket, app not open                             │
│  • Courier waits 10 minutes, leaves                                       │
│                                                                              │
│  Consequence:                                                               │
│  • Failed delivery                                                         │
│  • Re-delivery cost                                                        │
│  • Patient frustrated ("why didn't you call/text?")                       │
│                                                                              │
│  THE BALANCE WE NEED                                                       │
│  ─────────────────────────────────────────────────────────────────────────   │
│  • Enough to keep patient informed and confident                          │
│  • Not so many that they disable notifications                            │
│  • Critical moments (courier arriving) must use ALL channels              │
│  • Routine updates can be quieter (in-app only)                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Channel Analysis

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    NOTIFICATION CHANNELS ANALYSIS                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CHANNEL 1: PUSH NOTIFICATIONS (FCM)                                        │
│  ─────────────────────────────────────────────────────────────────────────   │
│  How it works:                                                              │
│  • Firebase Cloud Messaging sends to device token                          │
│  • Works even when app is closed (wakes device)                           │
│  • Appears in notification tray                                            │
│                                                                              │
│  Pros:                                                                      │
│  ✓ Instant delivery (< 1 second)                                          │
│  ✓ Free (unlimited messages)                                              │
│  ✓ Rich content (title, body, image, actions)                             │
│  ✓ Works when app backgrounded/closed                                     │
│                                                                              │
│  Cons:                                                                      │
│  ✗ Requires app installed                                                  │
│  ✗ User can disable (and many do after spam)                              │
│  ✗ Token can expire/change (need refresh logic)                           │
│  ✗ Web push has lower adoption than native                                │
│                                                                              │
│  Best for: All status updates, messages, reminders                        │
│                                                                              │
│  CHANNEL 2: SMS (Twilio)                                                   │
│  ─────────────────────────────────────────────────────────────────────────   │
│  How it works:                                                              │
│  • Twilio API sends SMS to phone number                                   │
│  • Works on any phone (smartphone or basic)                               │
│  • No internet required on recipient side                                 │
│                                                                              │
│  Pros:                                                                      │
│  ✓ 100% deliverability (everyone has phone number)                        │
│  ✓ Works offline (no internet needed)                                     │
│  ✓ Cannot be disabled by user                                             │
│  ✓ High open rate (98% read within 3 minutes)                            │
│                                                                              │
│  Cons:                                                                      │
│  ✗ EXPENSIVE: ~0.05 MAD per SMS (~0.005 USD)                             │
│  ✗ 160 character limit (longer = multiple SMS = 2x cost)                 │
│  ✗ No rich content (plain text only)                                     │
│  ✗ Regulatory limits in Morocco (ANRT registration)                      │
│                                                                              │
│  COST ANALYSIS:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Naive approach: SMS for every status change                        │   │
│  │  • 5 SMS per order × 1000 orders/day = 5000 SMS/day                │   │
│  │  • 5000 × 0.05 MAD = 250 MAD/day = 7,500 MAD/month                 │   │
│  │                                                                      │   │
│  │  Optimized approach: SMS only for CRITICAL                         │   │
│  │  • 1 SMS per order (courier arriving) = 1000 SMS/day               │   │
│  │  • 1000 × 0.05 MAD = 50 MAD/day = 1,500 MAD/month                  │   │
│  │                                                                      │   │
│  │  DECISION: Reserve SMS for truly critical moments only             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Best for: Courier arriving, payment failed (action required)             │
│                                                                              │
│  CHANNEL 3: IN-APP (Supabase Realtime)                                    │
│  ─────────────────────────────────────────────────────────────────────────   │
│  How it works:                                                              │
│  • Supabase Realtime broadcasts to channel                                │
│  • Client subscribes to user-specific channel                             │
│  • Instant delivery via WebSocket                                         │
│                                                                              │
│  Pros:                                                                      │
│  ✓ Free (included in Supabase)                                            │
│  ✓ Rich content (any JSON payload)                                        │
│  ✓ Instant (< 100ms)                                                      │
│  ✓ Persisted to database (notification history)                          │
│  ✓ Actions (mark read, click to navigate)                                 │
│                                                                              │
│  Cons:                                                                      │
│  ✗ Only works when app is open                                            │
│  ✗ Requires WebSocket connection                                          │
│  ✗ User must be actively using app                                        │
│                                                                              │
│  Best for: All notifications (as backup/history) + routine updates        │
│                                                                              │
│  CHANNEL 4: EMAIL (SendGrid)                                              │
│  ─────────────────────────────────────────────────────────────────────────   │
│  How it works:                                                              │
│  • SendGrid API sends templated emails                                    │
│  • Supports rich HTML content                                             │
│                                                                              │
│  Pros:                                                                      │
│  ✓ Long-form content (receipts, invoices)                                 │
│  ✓ Attachments possible                                                   │
│  ✓ Cheap (~0.001 MAD per email)                                          │
│                                                                              │
│  Cons:                                                                      │
│  ✗ Low open rates in Morocco (~15-20%)                                   │
│  ✗ Not instant (can take minutes)                                        │
│  ✗ Often goes to spam/promotions                                         │
│  ✗ Many Moroccans don't check email regularly                            │
│                                                                              │
│  Best for: Order receipts, monthly summaries, promotional (opt-in)       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Notification Tier System

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    NOTIFICATION TIER SYSTEM                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  TIER 1: CRITICAL (All Channels)                                           │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Channels: Push + SMS + In-app                                             │
│  Rate limit: None (always send)                                            │
│                                                                              │
│  Events:                                                                   │
│  • COURIER_ARRIVING (2 min away)                                          │
│    - Most important notification in entire system                         │
│    - SMS ensures delivery even if push disabled                          │
│    - "Votre livreur arrive dans 2 minutes"                               │
│                                                                              │
│  • PAYMENT_FAILED (action required)                                       │
│    - Order cannot proceed without action                                  │
│    - "Paiement échoué - veuillez mettre à jour"                          │
│                                                                              │
│  • PRESCRIPTION_EXPIRING_URGENT (medications needed)                      │
│    - Health impact if not renewed                                        │
│    - Only for prescriptions with orders in past                         │
│    - "Votre ordonnance expire demain"                                    │
│                                                                              │
│  TIER 2: IMPORTANT (Push + In-app)                                        │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Channels: Push + In-app (no SMS to save cost)                            │
│  Rate limit: Max 10 per hour per user                                     │
│                                                                              │
│  Events:                                                                   │
│  • ORDER_CONFIRMED - Pharmacy accepted                                    │
│  • ORDER_PREPARING - Started preparation                                  │
│  • ORDER_READY - Ready for courier                                        │
│  • COURIER_ASSIGNED - Courier on the way                                  │
│  • NEW_MESSAGE - Chat message received                                    │
│  • PRESCRIPTION_NEEDS_INFO - Pharmacy requesting info                    │
│                                                                              │
│  TIER 3: INFORMATIONAL (In-app Only)                                      │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Channels: In-app only (silent)                                           │
│  Rate limit: Max 20 per hour per user                                     │
│                                                                              │
│  Events:                                                                   │
│  • ORDER_DELIVERED - Delivery complete                                    │
│  • REVIEW_REMINDER - Ask for rating (24h after delivery)                 │
│  • PRESCRIPTION_SAVED - Upload processed                                  │
│  • ORDER_CANCELLED - By patient or pharmacy                              │
│  • PHARMACY_RESPONSE - Reply in chat                                     │
│                                                                              │
│  TIER 4: PROMOTIONAL (Opt-in Only)                                        │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Channels: In-app + Email (if marketing_opt_in = true)                    │
│  Rate limit: Max 1 per day per user                                       │
│                                                                              │
│  Events:                                                                   │
│  • NEW_PHARMACY_NEARBY - Partner expansion                               │
│  • DISCOUNT_AVAILABLE - Promotional offer                                │
│  • FEATURE_ANNOUNCEMENT - New functionality                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## DATABASE SCHEMA

### Notification Tables

```sql
-- ============================================================
-- NOTIFICATION SYSTEM DATABASE SCHEMA
-- ============================================================

-- Notification templates (admin-managed)
CREATE TABLE notification_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Identity
  type TEXT NOT NULL UNIQUE,         -- 'ORDER_CONFIRMED', 'COURIER_ARRIVING', etc.
  tier INTEGER NOT NULL DEFAULT 2,   -- 1=critical, 2=important, 3=info, 4=promo
  
  -- Channel configuration
  channels TEXT[] NOT NULL DEFAULT ARRAY['in_app'],
  -- Available: 'push', 'sms', 'in_app', 'email'
  
  -- French templates (primary)
  title_fr TEXT NOT NULL,
  body_fr TEXT NOT NULL,
  
  -- Arabic templates
  title_ar TEXT,
  body_ar TEXT,
  
  -- Push-specific
  push_icon TEXT,                    -- Icon name or URL
  push_color TEXT,                   -- Hex color for Android
  push_sound TEXT DEFAULT 'default', -- 'default', 'urgent', 'silent'
  push_click_action TEXT,            -- Deep link path
  
  -- SMS-specific
  sms_template TEXT,                 -- Shorter version for SMS (160 chars)
  
  -- Email-specific
  email_subject_fr TEXT,
  email_subject_ar TEXT,
  email_template_id TEXT,            -- SendGrid template ID
  
  -- Variables this template expects
  variables TEXT[] DEFAULT ARRAY[]::TEXT[],
  -- e.g., ['pharmacy_name', 'order_number', 'eta']
  
  -- Settings
  is_active BOOLEAN DEFAULT true,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert default templates
INSERT INTO notification_templates (type, tier, channels, title_fr, body_fr, sms_template, variables, push_click_action) VALUES
-- Tier 1: Critical
('COURIER_ARRIVING', 1, ARRAY['push', 'sms', 'in_app'], 
 'Livreur en approche', 
 '{{courier_name}} arrive dans {{eta}}. Préparez-vous à réceptionner votre commande.',
 'DAWA: Votre livreur arrive dans {{eta}}. Soyez prêt!',
 ARRAY['courier_name', 'eta', 'order_id'],
 '/orders/{{order_id}}/tracking'),

('PAYMENT_FAILED', 1, ARRAY['push', 'sms', 'in_app'],
 'Paiement échoué',
 'Le paiement de votre commande #{{order_number}} a échoué. Veuillez mettre à jour vos informations.',
 'DAWA: Paiement échoué pour commande #{{order_number}}. Mettez à jour: {{link}}',
 ARRAY['order_number', 'order_id', 'link'],
 '/orders/{{order_id}}/payment'),

-- Tier 2: Important
('ORDER_CONFIRMED', 2, ARRAY['push', 'in_app'],
 'Commande confirmée',
 '{{pharmacy_name}} prépare votre commande. Livraison estimée: {{eta}}',
 NULL,
 ARRAY['pharmacy_name', 'eta', 'order_id'],
 '/orders/{{order_id}}'),

('ORDER_READY', 2, ARRAY['push', 'in_app'],
 'Commande prête',
 'Votre commande est prête! Un livreur sera assigné sous peu.',
 NULL,
 ARRAY['order_id'],
 '/orders/{{order_id}}'),

('COURIER_ASSIGNED', 2, ARRAY['push', 'in_app'],
 'Livreur assigné',
 '{{courier_name}} est en route vers la pharmacie. Arrivée estimée: {{eta}}',
 NULL,
 ARRAY['courier_name', 'eta', 'order_id'],
 '/orders/{{order_id}}/tracking'),

('NEW_MESSAGE', 2, ARRAY['push', 'in_app'],
 'Nouveau message',
 '{{sender_name}}: {{message_preview}}',
 NULL,
 ARRAY['sender_name', 'message_preview', 'conversation_id'],
 '/messages/{{conversation_id}}'),

-- Tier 3: Info
('ORDER_DELIVERED', 3, ARRAY['in_app'],
 'Commande livrée',
 'Votre commande a été livrée avec succès. Merci de votre confiance!',
 NULL,
 ARRAY['order_id'],
 '/orders/{{order_id}}'),

('REVIEW_REMINDER', 3, ARRAY['in_app'],
 'Donnez votre avis',
 'Comment s''est passée votre commande chez {{pharmacy_name}}? Laissez un avis.',
 NULL,
 ARRAY['pharmacy_name', 'order_id'],
 '/orders/{{order_id}}/review');

-- User notifications (delivered/pending)
CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  -- Template reference
  template_type TEXT NOT NULL REFERENCES notification_templates(type),
  
  -- Computed content (after variable substitution)
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  
  -- Variable values used
  variables JSONB DEFAULT '{}'::jsonb,
  
  -- Related entities
  order_id UUID REFERENCES orders(id),
  pharmacy_id UUID REFERENCES pharmacies(id),
  
  -- Delivery status per channel
  push_status TEXT DEFAULT 'PENDING',  -- PENDING, SENT, FAILED, SKIPPED
  push_sent_at TIMESTAMPTZ,
  push_error TEXT,
  
  sms_status TEXT DEFAULT 'PENDING',
  sms_sent_at TIMESTAMPTZ,
  sms_error TEXT,
  sms_message_sid TEXT,                -- Twilio SID for tracking
  
  email_status TEXT DEFAULT 'PENDING',
  email_sent_at TIMESTAMPTZ,
  email_error TEXT,
  
  -- User interaction
  read_at TIMESTAMPTZ,
  clicked_at TIMESTAMPTZ,
  click_action TEXT,                   -- Where they clicked to
  
  -- Metadata
  tier INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_notifications_user_created ON notifications(user_id, created_at DESC);
CREATE INDEX idx_notifications_user_unread ON notifications(user_id, read_at) 
  WHERE read_at IS NULL;
CREATE INDEX idx_notifications_order ON notifications(order_id) WHERE order_id IS NOT NULL;

-- User notification preferences
CREATE TABLE notification_preferences (
  user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
  
  -- Push settings
  push_enabled BOOLEAN DEFAULT true,
  push_token TEXT,                     -- FCM token
  push_token_updated_at TIMESTAMPTZ,
  
  -- SMS settings
  sms_enabled BOOLEAN DEFAULT true,    -- User can opt out
  sms_phone TEXT,                      -- Verified phone number
  
  -- Email settings
  email_enabled BOOLEAN DEFAULT true,
  email_address TEXT,
  marketing_opt_in BOOLEAN DEFAULT false,
  
  -- Quiet hours (no non-critical notifications)
  quiet_hours_enabled BOOLEAN DEFAULT false,
  quiet_hours_start TIME DEFAULT '22:00',
  quiet_hours_end TIME DEFAULT '08:00',
  
  -- Per-type overrides (JSON: { "ORDER_CONFIRMED": false, ... })
  disabled_types TEXT[] DEFAULT ARRAY[]::TEXT[],
  
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Rate limiting tracking
CREATE TABLE notification_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  channel TEXT NOT NULL,               -- 'push', 'sms', 'email'
  window_start TIMESTAMPTZ NOT NULL,
  count INTEGER DEFAULT 1,
  
  UNIQUE(user_id, channel, window_start)
);

CREATE INDEX idx_rate_limits_user_channel ON notification_rate_limits(user_id, channel, window_start);
```

### Notification Functions

```sql
-- ============================================================
-- NOTIFICATION HELPER FUNCTIONS
-- ============================================================

-- Check if notification can be sent (rate limiting)
CREATE OR REPLACE FUNCTION can_send_notification(
  p_user_id UUID,
  p_channel TEXT,
  p_tier INTEGER
) RETURNS BOOLEAN AS $$
DECLARE
  v_count INTEGER;
  v_limit INTEGER;
  v_window_minutes INTEGER;
  v_prefs notification_preferences%ROWTYPE;
BEGIN
  -- Tier 1 (critical) always sends
  IF p_tier = 1 THEN
    RETURN TRUE;
  END IF;

  -- Get user preferences
  SELECT * INTO v_prefs FROM notification_preferences WHERE user_id = p_user_id;
  
  -- Check if channel is enabled
  IF p_channel = 'push' AND (v_prefs IS NULL OR NOT v_prefs.push_enabled) THEN
    RETURN FALSE;
  END IF;
  IF p_channel = 'sms' AND (v_prefs IS NULL OR NOT v_prefs.sms_enabled) THEN
    RETURN FALSE;
  END IF;
  
  -- Check quiet hours (for tier 2+)
  IF v_prefs.quiet_hours_enabled AND p_tier > 1 THEN
    IF (NOW() AT TIME ZONE 'Africa/Casablanca')::TIME 
       BETWEEN v_prefs.quiet_hours_start AND v_prefs.quiet_hours_end THEN
      RETURN FALSE;
    END IF;
  END IF;

  -- Rate limits by channel
  CASE p_channel
    WHEN 'push' THEN v_limit := 100; v_window_minutes := 60;  -- 100/hour
    WHEN 'sms' THEN v_limit := 10; v_window_minutes := 1440;  -- 10/day
    WHEN 'email' THEN v_limit := 20; v_window_minutes := 1440; -- 20/day
    ELSE RETURN TRUE;
  END CASE;

  -- Count recent notifications
  SELECT COALESCE(SUM(count), 0) INTO v_count
  FROM notification_rate_limits
  WHERE user_id = p_user_id
    AND channel = p_channel
    AND window_start > NOW() - (v_window_minutes || ' minutes')::INTERVAL;

  RETURN v_count < v_limit;
END;
$$ LANGUAGE plpgsql;

-- Interpolate template variables
CREATE OR REPLACE FUNCTION interpolate_template(
  p_template TEXT,
  p_variables JSONB
) RETURNS TEXT AS $$
DECLARE
  v_result TEXT := p_template;
  v_key TEXT;
  v_value TEXT;
BEGIN
  FOR v_key, v_value IN SELECT * FROM jsonb_each_text(p_variables)
  LOOP
    v_result := REPLACE(v_result, '{{' || v_key || '}}', COALESCE(v_value, ''));
  END LOOP;
  RETURN v_result;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Get unread notification count
CREATE OR REPLACE FUNCTION get_unread_count(p_user_id UUID)
RETURNS INTEGER AS $$
  SELECT COUNT(*)::INTEGER 
  FROM notifications 
  WHERE user_id = p_user_id 
    AND read_at IS NULL;
$$ LANGUAGE sql STABLE;
```

---

## IMPLEMENTATION

### Notification Service (Edge Function)

```typescript
// supabase/functions/send-notification/index.ts

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

// ═══════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════

interface NotificationRequest {
  userId: string;
  templateType: string;
  variables: Record<string, string>;
  orderId?: string;
  pharmacyId?: string;
}

interface NotificationTemplate {
  type: string;
  tier: number;
  channels: string[];
  title_fr: string;
  body_fr: string;
  sms_template: string | null;
  push_click_action: string | null;
  variables: string[];
}

// ═══════════════════════════════════════════════════════════════
// CHANNEL SENDERS
// ═══════════════════════════════════════════════════════════════

async function sendPushNotification(
  token: string,
  title: string,
  body: string,
  data: Record<string, string>,
  clickAction?: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const response = await fetch('https://fcm.googleapis.com/fcm/send', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `key=${Deno.env.get('FCM_SERVER_KEY')}`,
      },
      body: JSON.stringify({
        to: token,
        notification: {
          title,
          body,
          click_action: clickAction,
          icon: '/icons/notification-icon.png',
        },
        data: {
          ...data,
          click_action: clickAction,
        },
        android: {
          priority: 'high',
          notification: {
            sound: 'default',
            channel_id: 'dawa_orders',
          },
        },
        apns: {
          payload: {
            aps: {
              sound: 'default',
              badge: 1,
            },
          },
        },
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      return { success: false, error };
    }

    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function sendSMS(
  phone: string,
  message: string
): Promise<{ success: boolean; sid?: string; error?: string }> {
  try {
    const accountSid = Deno.env.get('TWILIO_ACCOUNT_SID');
    const authToken = Deno.env.get('TWILIO_AUTH_TOKEN');
    const fromNumber = Deno.env.get('TWILIO_FROM_NUMBER');

    const response = await fetch(
      `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Authorization': 'Basic ' + btoa(`${accountSid}:${authToken}`),
        },
        body: new URLSearchParams({
          To: phone,
          From: fromNumber!,
          Body: message,
        }),
      }
    );

    const data = await response.json();

    if (!response.ok) {
      return { success: false, error: data.message };
    }

    return { success: true, sid: data.sid };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ═══════════════════════════════════════════════════════════════
// MAIN HANDLER
// ═══════════════════════════════════════════════════════════════

serve(async (req) => {
  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );

    const { userId, templateType, variables, orderId, pharmacyId }: NotificationRequest = 
      await req.json();

    // ─────────────────────────────────────────────────────────────
    // 1. Get template
    // ─────────────────────────────────────────────────────────────
    const { data: template, error: templateError } = await supabase
      .from('notification_templates')
      .select('*')
      .eq('type', templateType)
      .eq('is_active', true)
      .single();

    if (templateError || !template) {
      return new Response(
        JSON.stringify({ error: 'Template not found', type: templateType }),
        { status: 404 }
      );
    }

    // ─────────────────────────────────────────────────────────────
    // 2. Get user preferences
    // ─────────────────────────────────────────────────────────────
    const { data: prefs } = await supabase
      .from('notification_preferences')
      .select('*')
      .eq('user_id', userId)
      .single();

    // Check if user disabled this type
    if (prefs?.disabled_types?.includes(templateType)) {
      return new Response(
        JSON.stringify({ skipped: true, reason: 'User disabled this notification type' }),
        { status: 200 }
      );
    }

    // ─────────────────────────────────────────────────────────────
    // 3. Interpolate templates
    // ─────────────────────────────────────────────────────────────
    const interpolate = (text: string): string => {
      let result = text;
      for (const [key, value] of Object.entries(variables)) {
        result = result.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), value);
      }
      return result;
    };

    const title = interpolate(template.title_fr);
    const body = interpolate(template.body_fr);
    const smsText = template.sms_template ? interpolate(template.sms_template) : null;
    const clickAction = template.push_click_action 
      ? interpolate(template.push_click_action) 
      : undefined;

    // ─────────────────────────────────────────────────────────────
    // 4. Create notification record
    // ─────────────────────────────────────────────────────────────
    const { data: notification, error: insertError } = await supabase
      .from('notifications')
      .insert({
        user_id: userId,
        template_type: templateType,
        title,
        body,
        variables,
        order_id: orderId,
        pharmacy_id: pharmacyId,
        tier: template.tier,
        push_status: template.channels.includes('push') ? 'PENDING' : 'SKIPPED',
        sms_status: template.channels.includes('sms') ? 'PENDING' : 'SKIPPED',
        email_status: template.channels.includes('email') ? 'PENDING' : 'SKIPPED',
      })
      .select()
      .single();

    if (insertError) {
      console.error('Failed to create notification:', insertError);
      return new Response(
        JSON.stringify({ error: 'Failed to create notification' }),
        { status: 500 }
      );
    }

    const results: Record<string, any> = { notificationId: notification.id };

    // ─────────────────────────────────────────────────────────────
    // 5. Send via each channel
    // ─────────────────────────────────────────────────────────────

    // PUSH
    if (template.channels.includes('push') && prefs?.push_token && prefs?.push_enabled) {
      // Check rate limit (skip for tier 1)
      const { data: canSend } = await supabase.rpc('can_send_notification', {
        p_user_id: userId,
        p_channel: 'push',
        p_tier: template.tier,
      });

      if (canSend) {
        const pushResult = await sendPushNotification(
          prefs.push_token,
          title,
          body,
          { notificationId: notification.id, orderId: orderId || '' },
          clickAction
        );

        await supabase
          .from('notifications')
          .update({
            push_status: pushResult.success ? 'SENT' : 'FAILED',
            push_sent_at: pushResult.success ? new Date().toISOString() : null,
            push_error: pushResult.error,
          })
          .eq('id', notification.id);

        results.push = pushResult;

        // Update rate limit
        if (pushResult.success) {
          await supabase.from('notification_rate_limits').upsert({
            user_id: userId,
            channel: 'push',
            window_start: new Date().toISOString(),
            count: 1,
          }, {
            onConflict: 'user_id,channel,window_start',
          });
        }
      } else {
        results.push = { skipped: true, reason: 'Rate limited' };
      }
    }

    // SMS (only for tier 1)
    if (template.channels.includes('sms') && smsText && prefs?.sms_phone && prefs?.sms_enabled) {
      const { data: canSend } = await supabase.rpc('can_send_notification', {
        p_user_id: userId,
        p_channel: 'sms',
        p_tier: template.tier,
      });

      if (canSend) {
        const smsResult = await sendSMS(prefs.sms_phone, smsText);

        await supabase
          .from('notifications')
          .update({
            sms_status: smsResult.success ? 'SENT' : 'FAILED',
            sms_sent_at: smsResult.success ? new Date().toISOString() : null,
            sms_error: smsResult.error,
            sms_message_sid: smsResult.sid,
          })
          .eq('id', notification.id);

        results.sms = smsResult;
      } else {
        results.sms = { skipped: true, reason: 'Rate limited' };
      }
    }

    // IN-APP (Realtime broadcast)
    if (template.channels.includes('in_app')) {
      const channel = supabase.channel(`user:${userId}`);
      await channel.send({
        type: 'broadcast',
        event: 'notification',
        payload: {
          id: notification.id,
          type: templateType,
          title,
          body,
          orderId,
          tier: template.tier,
          clickAction,
          createdAt: notification.created_at,
        },
      });
      results.in_app = { success: true };
    }

    return new Response(JSON.stringify(results), { status: 200 });

  } catch (error) {
    console.error('Notification error:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500 }
    );
  }
});
```

### Client-Side Notification Hook

```typescript
// apps/patient/src/hooks/useNotifications.ts

import { useEffect, useState, useCallback, useRef } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { RealtimeChannel } from '@supabase/supabase-js';
import { getSupabaseClient } from '@/lib/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import { playNotificationSound } from '@/lib/sounds';

// ═══════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════

export interface Notification {
  id: string;
  templateType: string;
  title: string;
  body: string;
  orderId?: string;
  tier: number;
  clickAction?: string;
  readAt: string | null;
  createdAt: string;
}

// ═══════════════════════════════════════════════════════════════
// HOOK
// ═══════════════════════════════════════════════════════════════

export function useNotifications() {
  const { user } = useAuth();
  const supabase = getSupabaseClient();
  const queryClient = useQueryClient();
  const channelRef = useRef<RealtimeChannel | null>(null);
  
  // Toast state for showing new notifications
  const [toast, setToast] = useState<Notification | null>(null);

  // ─────────────────────────────────────────────────────────────
  // Fetch notifications
  // ─────────────────────────────────────────────────────────────
  const { data: notifications = [], isLoading } = useQuery({
    queryKey: ['notifications', user?.id],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('notifications')
        .select('*')
        .eq('user_id', user!.id)
        .order('created_at', { ascending: false })
        .limit(50);

      if (error) throw error;

      return (data || []).map((n): Notification => ({
        id: n.id,
        templateType: n.template_type,
        title: n.title,
        body: n.body,
        orderId: n.order_id,
        tier: n.tier,
        clickAction: n.click_action,
        readAt: n.read_at,
        createdAt: n.created_at,
      }));
    },
    enabled: !!user,
  });

  // ─────────────────────────────────────────────────────────────
  // Unread count
  // ─────────────────────────────────────────────────────────────
  const unreadCount = notifications.filter(n => !n.readAt).length;

  // ─────────────────────────────────────────────────────────────
  // Mark as read
  // ─────────────────────────────────────────────────────────────
  const markAsReadMutation = useMutation({
    mutationFn: async (notificationId: string) => {
      const { error } = await supabase
        .from('notifications')
        .update({ read_at: new Date().toISOString() })
        .eq('id', notificationId);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
  });

  const markAllAsReadMutation = useMutation({
    mutationFn: async () => {
      const { error } = await supabase
        .from('notifications')
        .update({ read_at: new Date().toISOString() })
        .eq('user_id', user!.id)
        .is('read_at', null);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
  });

  // ─────────────────────────────────────────────────────────────
  // Real-time subscription
  // ─────────────────────────────────────────────────────────────
  useEffect(() => {
    if (!user) return;

    const channel = supabase
      .channel(`user:${user.id}`)
      .on('broadcast', { event: 'notification' }, (payload) => {
        const notification = payload.payload as Notification;
        
        // Play sound for important notifications
        if (notification.tier <= 2) {
          playNotificationSound(notification.tier === 1 ? 'urgent' : 'default');
        }

        // Show toast
        setToast(notification);
        setTimeout(() => setToast(null), 5000);

        // Refresh list
        queryClient.invalidateQueries({ queryKey: ['notifications'] });
      })
      .subscribe();

    channelRef.current = channel;

    return () => {
      if (channelRef.current) {
        supabase.removeChannel(channelRef.current);
      }
    };
  }, [user, supabase, queryClient]);

  // ─────────────────────────────────────────────────────────────
  // Dismiss toast
  // ─────────────────────────────────────────────────────────────
  const dismissToast = useCallback(() => {
    setToast(null);
  }, []);

  return {
    notifications,
    unreadCount,
    isLoading,
    toast,
    dismissToast,
    markAsRead: markAsReadMutation.mutate,
    markAllAsRead: markAllAsReadMutation.mutate,
  };
}
```

### Push Token Registration

```typescript
// apps/patient/src/lib/push/register.ts

import { getSupabaseClient } from '@/lib/supabase/client';

/**
 * Register for push notifications
 * Requests permission and stores FCM token
 */
export async function registerForPushNotifications(): Promise<boolean> {
  // Check if browser supports notifications
  if (!('Notification' in window)) {
    console.warn('This browser does not support notifications');
    return false;
  }

  // Request permission
  const permission = await Notification.requestPermission();
  if (permission !== 'granted') {
    console.warn('Notification permission denied');
    return false;
  }

  // Get FCM token
  try {
    const { getToken } = await import('firebase/messaging');
    const { messaging } = await import('@/lib/firebase');
    
    const token = await getToken(messaging, {
      vapidKey: process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY,
    });

    if (!token) {
      console.warn('Failed to get FCM token');
      return false;
    }

    // Store token in database
    const supabase = getSupabaseClient();
    const { error } = await supabase
      .from('notification_preferences')
      .upsert({
        user_id: (await supabase.auth.getUser()).data.user!.id,
        push_enabled: true,
        push_token: token,
        push_token_updated_at: new Date().toISOString(),
      }, {
        onConflict: 'user_id',
      });

    if (error) {
      console.error('Failed to store push token:', error);
      return false;
    }

    console.log('Push notifications registered successfully');
    return true;

  } catch (error) {
    console.error('Failed to register for push:', error);
    return false;
  }
}
```

### Notification Center Component

```typescript
// apps/patient/src/components/features/notifications/notification-center.tsx

'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Bell, Check, CheckCheck, X, ChevronRight, Package, MessageCircle, AlertCircle } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';
import { fr } from 'date-fns/locale';
import Link from 'next/link';

import { useNotifications, Notification } from '@/hooks/useNotifications';
import { cn } from '@/lib/utils';

export function NotificationCenter() {
  const [isOpen, setIsOpen] = useState(false);
  const { notifications, unreadCount, markAsRead, markAllAsRead, toast, dismissToast } = useNotifications();

  // Group notifications by date
  const today = new Date().toDateString();
  const groupedNotifications = notifications.reduce((acc, notif) => {
    const date = new Date(notif.createdAt).toDateString();
    const key = date === today ? 'Aujourd\'hui' : formatDistanceToNow(new Date(notif.createdAt), { locale: fr, addSuffix: true });
    if (!acc[key]) acc[key] = [];
    acc[key].push(notif);
    return acc;
  }, {} as Record<string, Notification[]>);

  return (
    <>
      {/* Bell trigger */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 rounded-full hover:bg-gray-100 transition-colors"
      >
        <Bell className="h-5 w-5 text-gray-600" />
        {unreadCount > 0 && (
          <span className="absolute -top-0.5 -right-0.5 flex h-5 w-5 items-center justify-center rounded-full bg-red-500 text-[10px] font-bold text-white">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </button>

      {/* Dropdown */}
      <AnimatePresence>
        {isOpen && (
          <>
            {/* Backdrop */}
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="fixed inset-0 z-40"
              onClick={() => setIsOpen(false)}
            />

            {/* Panel */}
            <motion.div
              initial={{ opacity: 0, y: -10, scale: 0.95 }}
              animate={{ opacity: 1, y: 0, scale: 1 }}
              exit={{ opacity: 0, y: -10, scale: 0.95 }}
              transition={{ duration: 0.15 }}
              className="absolute right-0 top-full mt-2 w-96 max-h-[32rem] overflow-hidden rounded-2xl bg-white shadow-xl border border-gray-200 z-50"
            >
              {/* Header */}
              <div className="flex items-center justify-between px-4 py-3 border-b border-gray-100">
                <h3 className="font-semibold text-gray-900">Notifications</h3>
                {unreadCount > 0 && (
                  <button
                    onClick={() => markAllAsRead()}
                    className="text-sm text-primary-600 hover:text-primary-700 font-medium flex items-center gap-1"
                  >
                    <CheckCheck className="h-4 w-4" />
                    Tout marquer lu
                  </button>
                )}
              </div>

              {/* List */}
              <div className="overflow-y-auto max-h-[26rem]">
                {notifications.length === 0 ? (
                  <div className="py-12 text-center">
                    <Bell className="h-10 w-10 text-gray-300 mx-auto mb-3" />
                    <p className="text-gray-500">Aucune notification</p>
                  </div>
                ) : (
                  Object.entries(groupedNotifications).map(([date, items]) => (
                    <div key={date}>
                      <div className="px-4 py-2 bg-gray-50 text-xs font-medium text-gray-500 uppercase">
                        {date}
                      </div>
                      {items.map((notif) => (
                        <NotificationItem
                          key={notif.id}
                          notification={notif}
                          onRead={() => markAsRead(notif.id)}
                          onClose={() => setIsOpen(false)}
                        />
                      ))}
                    </div>
                  ))
                )}
              </div>
            </motion.div>
          </>
        )}
      </AnimatePresence>

      {/* Toast for new notifications */}
      <AnimatePresence>
        {toast && (
          <motion.div
            initial={{ opacity: 0, y: -20, x: 20 }}
            animate={{ opacity: 1, y: 0, x: 0 }}
            exit={{ opacity: 0, y: -20 }}
            className="fixed top-20 right-4 z-50 w-80 rounded-xl bg-white shadow-xl border border-gray-200 overflow-hidden"
          >
            <div className={cn(
              'px-4 py-3',
              toast.tier === 1 && 'bg-red-50 border-b border-red-100',
              toast.tier === 2 && 'bg-yellow-50 border-b border-yellow-100'
            )}>
              <div className="flex items-start gap-3">
                <NotificationIcon type={toast.templateType} tier={toast.tier} />
                <div className="flex-1 min-w-0">
                  <p className="font-medium text-gray-900 truncate">{toast.title}</p>
                  <p className="text-sm text-gray-600 line-clamp-2">{toast.body}</p>
                </div>
                <button onClick={dismissToast} className="p-1 hover:bg-gray-100 rounded">
                  <X className="h-4 w-4 text-gray-400" />
                </button>
              </div>
            </div>
            {toast.clickAction && (
              <Link
                href={toast.clickAction}
                onClick={dismissToast}
                className="block px-4 py-2 text-sm text-primary-600 hover:bg-gray-50 font-medium"
              >
                Voir les détails →
              </Link>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
}

function NotificationItem({ 
  notification, 
  onRead, 
  onClose 
}: { 
  notification: Notification; 
  onRead: () => void;
  onClose: () => void;
}) {
  const handleClick = () => {
    if (!notification.readAt) {
      onRead();
    }
    onClose();
  };

  const content = (
    <div className={cn(
      'flex items-start gap-3 px-4 py-3 hover:bg-gray-50 transition-colors cursor-pointer',
      !notification.readAt && 'bg-primary-50/50'
    )}>
      <NotificationIcon type={notification.templateType} tier={notification.tier} />
      <div className="flex-1 min-w-0">
        <p className={cn(
          'text-sm',
          notification.readAt ? 'text-gray-600' : 'text-gray-900 font-medium'
        )}>
          {notification.title}
        </p>
        <p className="text-sm text-gray-500 line-clamp-2">{notification.body}</p>
        <p className="text-xs text-gray-400 mt-1">
          {formatDistanceToNow(new Date(notification.createdAt), { locale: fr, addSuffix: true })}
        </p>
      </div>
      {!notification.readAt && (
        <div className="h-2 w-2 rounded-full bg-primary-500 shrink-0 mt-2" />
      )}
    </div>
  );

  if (notification.clickAction) {
    return (
      <Link href={notification.clickAction} onClick={handleClick}>
        {content}
      </Link>
    );
  }

  return <div onClick={handleClick}>{content}</div>;
}

function NotificationIcon({ type, tier }: { type: string; tier: number }) {
  const baseClass = 'h-10 w-10 rounded-full flex items-center justify-center shrink-0';
  
  if (tier === 1) {
    return (
      <div className={cn(baseClass, 'bg-red-100')}>
        <AlertCircle className="h-5 w-5 text-red-600" />
      </div>
    );
  }

  if (type.includes('ORDER') || type.includes('COURIER')) {
    return (
      <div className={cn(baseClass, 'bg-primary-100')}>
        <Package className="h-5 w-5 text-primary-600" />
      </div>
    );
  }

  if (type.includes('MESSAGE')) {
    return (
      <div className={cn(baseClass, 'bg-blue-100')}>
        <MessageCircle className="h-5 w-5 text-blue-600" />
      </div>
    );
  }

  return (
    <div className={cn(baseClass, 'bg-gray-100')}>
      <Bell className="h-5 w-5 text-gray-600" />
    </div>
  );
}
```

---

## SUCCESS CRITERIA

- [ ] 4-tier notification system (Critical, Important, Info, Promotional)
- [ ] Push notifications via FCM with token refresh
- [ ] SMS via Twilio for critical only (cost control)
- [ ] Real-time in-app via Supabase Realtime
- [ ] Template system with variable interpolation
- [ ] Rate limiting per channel per user
- [ ] Quiet hours respecting user preferences
- [ ] Unread count badge on bell icon
- [ ] Notification center dropdown with grouping
- [ ] Toast notifications for new items
- [ ] Mark as read / mark all as read
- [ ] Deep linking from notifications to relevant screens
- [ ] Sound differentiation (urgent vs default)

---

## PHASE 1 COMPLETE ✅

All Patient Web App prompts are now complete:
- P1.1: Patient Web App Setup
- P1.2: Patient Auth Screens
- P1.3: Rx Verification
- P1.4: Patient Home Dashboard
- P1.5: Order Creation Flow
- P1.6: Order Tracking
- P1.7: Order History
- P1.8: Pharmacy Discovery
- P1.9: Prescription Management
- P1.10: Profile Settings
- P1.11: Chat System
- P1.12: Notifications

---

## NEXT STEP

Proceed to Phase 2 - Pharmacy Portal:
→ `dawa-docs/prompts/phase-2/P2.1-pharmacy-portal-setup.md`

Reference documentation:
→ `dawa-docs/docs/DAWA_MASTER.md`
→ `dawa-docs/docs/phases/PHASE_2.md`
