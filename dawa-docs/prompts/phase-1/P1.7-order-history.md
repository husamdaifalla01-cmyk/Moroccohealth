# P1.7 — Order History (V100)

## Prompt ID: P1.7
## Phase: 1 - Patient Web App
## Estimated Time: 6-8 hours
## Prerequisites: P1.6 complete

---

## STRATEGIC CONTEXT

### The Problem We're Actually Solving

Order History is not just a list. It serves multiple critical user needs:

1. **Reference Tool**: "What did I order last time for my blood pressure?"
2. **Reorder Shortcut**: "Same as before, please" — one tap for chronic patients
3. **Expense Tracking**: "I need receipts for insurance reimbursement"
4. **Trust Builder**: "Look at all my successful orders with DAWA"
5. **Support Tool**: "My last order had an issue, I need to reference it"

### User Persona Analysis

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          USER PERSONAS                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  PERSONA 1: CHRONIC CONDITION PATIENT                                       │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Profile: Orders same medications monthly (diabetes, hypertension)          │
│  Frequency: 1-2 orders per month, same items                               │
│  Primary Need: One-click reorder                                            │
│  Pain Point: "Why do I have to search for the same thing every time?"      │
│                                                                              │
│  DESIGN IMPLICATION:                                                        │
│  - Prominent "Recommander" button on recent orders                         │
│  - "Commandes fréquentes" section showing repeated orders                  │
│  - Smart suggestions based on order patterns                               │
│                                                                              │
│  PERSONA 2: OCCASIONAL USER                                                 │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Profile: Orders 2-3 times per year (cold medicine, antibiotics)           │
│  Frequency: Sporadic, different items                                       │
│  Primary Need: Find that one order from 6 months ago                       │
│  Pain Point: "I can't remember what pharmacy I used"                       │
│                                                                              │
│  DESIGN IMPLICATION:                                                        │
│  - Powerful search (by medication name, pharmacy, date)                    │
│  - Date range filters                                                       │
│  - Clear order summaries showing all items                                 │
│                                                                              │
│  PERSONA 3: CAREGIVER                                                       │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Profile: Manages medications for elderly parent or child                  │
│  Frequency: Regular orders, needs documentation                            │
│  Primary Need: Clear records for doctor visits                             │
│  Pain Point: "I need to show the doctor what medications were ordered"     │
│                                                                              │
│  DESIGN IMPLICATION:                                                        │
│  - Detailed order view with all medications                                │
│  - PDF export/share functionality                                          │
│  - Print-friendly receipt format                                           │
│                                                                              │
│  PERSONA 4: EXPENSE TRACKER                                                 │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Profile: Uses private insurance, needs reimbursement                      │
│  Frequency: Any                                                             │
│  Primary Need: Official receipts for insurance claims                      │
│  Pain Point: "I need receipts with pharmacy stamp and totals"              │
│                                                                              │
│  DESIGN IMPLICATION:                                                        │
│  - PDF receipt generation with pharmacy details                            │
│  - Bulk export (CSV) for expense tracking                                  │
│  - Clear itemization with prices                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## TECHNICAL ARCHITECTURE

### Pagination Strategy

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    PAGINATION STRATEGY ANALYSIS                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  OPTION A: OFFSET PAGINATION                                                │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Query: SELECT * FROM orders LIMIT 20 OFFSET 40                            │
│                                                                              │
│  ❌ PROBLEMS:                                                               │
│  - New orders shift indices (page 3 becomes stale if new order arrives)   │
│  - Performance degrades with high offsets (DB must count N rows)          │
│  - Duplicates or missed items when data changes between pages              │
│                                                                              │
│  OPTION B: CURSOR-BASED PAGINATION (CHOSEN)                                │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Query: SELECT * FROM orders                                               │
│         WHERE created_at < :cursor                                         │
│         ORDER BY created_at DESC                                           │
│         LIMIT 20                                                           │
│                                                                              │
│  ✓ BENEFITS:                                                               │
│  - Stable pagination (new orders don't shift existing pages)              │
│  - O(1) performance regardless of page depth                               │
│  - Works with real-time updates                                            │
│                                                                              │
│  IMPLEMENTATION:                                                            │
│  - Cursor = created_at of last item in current page                        │
│  - Use React Query's useInfiniteQuery for seamless loading                │
│  - Store cursor in URL for shareable pagination                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Search Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       SEARCH CAPABILITIES                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SEARCH FIELDS:                                                             │
│  ──────────────                                                             │
│  1. Order number (exact match): "DW-2024-001234"                           │
│  2. Pharmacy name (contains): "Atlas"                                       │
│  3. Medication name (contains): "Paracétamol"                              │
│  4. Status (enum): "DELIVERED", "CANCELLED"                                │
│  5. Date range: "Last 30 days", "This year", custom range                  │
│                                                                              │
│  IMPLEMENTATION STRATEGY:                                                   │
│  ────────────────────────                                                   │
│  - Simple search: Combined query on order_number + pharmacy_name           │
│  - Medication search: JOIN with order_items and medications tables         │
│  - Date filtering: WHERE clause on created_at                              │
│                                                                              │
│  DEBOUNCING:                                                                │
│  ───────────                                                                │
│  - 300ms debounce on search input                                          │
│  - Instant filter changes (status, date range)                             │
│  - Clear search button resets all filters                                  │
│                                                                              │
│  QUERY STRUCTURE:                                                           │
│  ────────────────                                                           │
│  ```sql                                                                     │
│  SELECT o.*, p.name as pharmacy_name                                       │
│  FROM orders o                                                              │
│  JOIN pharmacies p ON o.pharmacy_id = p.id                                 │
│  WHERE o.patient_id = :patient_id                                          │
│    AND (                                                                    │
│      o.order_number ILIKE :search                                          │
│      OR p.name ILIKE :search                                               │
│      OR EXISTS (                                                            │
│        SELECT 1 FROM order_items oi                                        │
│        JOIN medications m ON oi.medication_id = m.id                       │
│        WHERE oi.order_id = o.id AND m.name ILIKE :search                  │
│      )                                                                      │
│    )                                                                        │
│    AND (:status IS NULL OR o.status = :status)                             │
│    AND o.created_at BETWEEN :date_from AND :date_to                       │
│    AND o.created_at < :cursor                                              │
│  ORDER BY o.created_at DESC                                                │
│  LIMIT 20                                                                   │
│  ```                                                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Caching Strategy

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    REACT QUERY CACHING STRATEGY                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CACHE KEY STRUCTURE:                                                       │
│  ────────────────────                                                       │
│  ['orders', patientId, { search, status, dateRange }]                      │
│                                                                              │
│  STALE TIME BY ORDER STATUS:                                               │
│  ───────────────────────────                                                │
│  - Active orders (IN_TRANSIT, etc.): 30 seconds                            │
│    → Might update any moment, need fresh data                              │
│                                                                              │
│  - Completed orders (DELIVERED): 5 minutes                                 │
│    → Won't change, safe to cache longer                                    │
│                                                                              │
│  - Cancelled/Error orders: Infinity                                        │
│    → Will never change, cache forever                                      │
│                                                                              │
│  CACHE INVALIDATION:                                                        │
│  ───────────────────                                                        │
│  - On real-time order status update → invalidate specific order            │
│  - On new order created → invalidate list query                            │
│  - On reorder action → invalidate after success                            │
│                                                                              │
│  OPTIMISTIC UPDATES:                                                        │
│  ───────────────────                                                        │
│  - Reorder button → Immediately show "Commande créée" toast               │
│  - Cancel order → Immediately update status in UI                          │
│  - Rollback on server error                                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Reorder Flow Complexity

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    REORDER EDGE CASES                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  PROBLEM 1: MEDICATION DISCONTINUED                                         │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Scenario: Patient reorders, but "Doliprane 500mg" is no longer available  │
│                                                                              │
│  Solution:                                                                   │
│  1. Check availability before adding to cart                                │
│  2. Show warning: "1 article non disponible"                               │
│  3. Offer alternatives: "Doliprane 1000mg est disponible"                  │
│  4. Allow partial reorder (available items only)                           │
│                                                                              │
│  PROBLEM 2: PHARMACY CLOSED/DEACTIVATED                                    │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Scenario: Previous pharmacy is permanently closed                          │
│                                                                              │
│  Solution:                                                                   │
│  1. Detect pharmacy status before reorder                                   │
│  2. Show message: "Pharmacie Atlas est fermée"                             │
│  3. Offer: "Voulez-vous commander dans une pharmacie proche?"              │
│  4. Pre-fill cart, let patient choose new pharmacy                         │
│                                                                              │
│  PROBLEM 3: PRESCRIPTION EXPIRED                                           │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Scenario: Order contained prescription items, prescription now expired    │
│                                                                              │
│  Solution:                                                                   │
│  1. Check prescription expiry on original order                            │
│  2. Show warning: "Votre ordonnance a expiré"                              │
│  3. Require new prescription upload                                        │
│  4. OTC items can proceed without prescription                             │
│                                                                              │
│  PROBLEM 4: SIGNIFICANT PRICE CHANGE                                       │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Scenario: Prices increased >20% since last order                          │
│                                                                              │
│  Solution:                                                                   │
│  1. Calculate price difference                                              │
│  2. Show alert if increase >20%: "Prix mis à jour: 89 DH → 120 DH"        │
│  3. Require confirmation before proceeding                                 │
│                                                                              │
│  PROBLEM 5: QUANTITY LIMITS                                                │
│  ─────────────────────────────────────────────────────────────────────────   │
│  Scenario: Previous order had 5 boxes, new limit is 3 per order            │
│                                                                              │
│  Solution:                                                                   │
│  1. Apply current limits to reorder                                        │
│  2. Show info: "Quantité ajustée: max 3 par commande"                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## IMPLEMENTATION

### Step 1: Orders List Query Hook

Create `apps/patient/src/hooks/useOrdersQuery.ts`:

```typescript
// ============================================================
// useOrdersQuery Hook
// 
// Provides paginated, filterable, searchable order list
// with proper caching and real-time invalidation.
// ============================================================

import { useInfiniteQuery, useQueryClient } from '@tanstack/react-query';
import { useEffect, useMemo } from 'react';

import { getSupabaseClient } from '@/lib/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import type { Order, OrderStatus } from '@dawa/types';

// ─────────────────────────────────────────────────────────────
// TYPES
// ─────────────────────────────────────────────────────────────

export type OrderFilterStatus = 
  | 'all' 
  | 'active' 
  | 'delivered' 
  | 'cancelled';

export interface OrderFilters {
  search: string;
  status: OrderFilterStatus;
  dateFrom: Date | null;
  dateTo: Date | null;
}

export interface OrderWithDetails extends Order {
  pharmacy: {
    id: string;
    name: string;
    logo_url: string | null;
    address: string;
  };
  items: Array<{
    id: string;
    quantity: number;
    unit_price: number;
    medication: {
      id: string;
      name: string;
      dosage: string;
    };
  }>;
  _itemCount: number;
}

interface UseOrdersQueryOptions {
  filters: OrderFilters;
  pageSize?: number;
}

// ─────────────────────────────────────────────────────────────
// CONSTANTS
// ─────────────────────────────────────────────────────────────

const DEFAULT_PAGE_SIZE = 20;

// Map filter status to actual database statuses
const STATUS_GROUPS: Record<OrderFilterStatus, OrderStatus[] | null> = {
  all: null, // No filter
  active: [
    'PENDING_PHARMACY',
    'CONFIRMED',
    'PREPARING',
    'READY_FOR_PICKUP',
    'ASSIGNED_TO_COURIER',
    'COURIER_PICKED_UP',
    'IN_TRANSIT',
    'ARRIVED',
  ],
  delivered: ['DELIVERED'],
  cancelled: ['CANCELLED', 'RETURNED', 'REFUNDED', 'FAILED_DELIVERY'],
};

// ─────────────────────────────────────────────────────────────
// HOOK
// ─────────────────────────────────────────────────────────────

export function useOrdersQuery({ 
  filters, 
  pageSize = DEFAULT_PAGE_SIZE 
}: UseOrdersQueryOptions) {
  const { patient } = useAuth();
  const supabase = getSupabaseClient();
  const queryClient = useQueryClient();

  // Build query key from filters (for caching)
  const queryKey = useMemo(() => [
    'orders',
    patient?.id,
    {
      search: filters.search,
      status: filters.status,
      dateFrom: filters.dateFrom?.toISOString(),
      dateTo: filters.dateTo?.toISOString(),
    },
  ], [patient?.id, filters]);

  // Main query
  const query = useInfiniteQuery({
    queryKey,
    queryFn: async ({ pageParam }) => {
      if (!patient?.id) return [];

      // Start building query
      let q = supabase
        .from('orders')
        .select(`
          *,
          pharmacy:pharmacies!inner (
            id,
            name,
            logo_url,
            address
          ),
          items:order_items (
            id,
            quantity,
            unit_price,
            medication:medications (
              id,
              name,
              dosage
            )
          )
        `)
        .eq('patient_id', patient.id)
        .order('created_at', { ascending: false })
        .limit(pageSize);

      // Apply cursor pagination
      if (pageParam) {
        q = q.lt('created_at', pageParam);
      }

      // Apply status filter
      const statusGroup = STATUS_GROUPS[filters.status];
      if (statusGroup) {
        q = q.in('status', statusGroup);
      }

      // Apply date range filter
      if (filters.dateFrom) {
        q = q.gte('created_at', filters.dateFrom.toISOString());
      }
      if (filters.dateTo) {
        q = q.lte('created_at', filters.dateTo.toISOString());
      }

      // Apply search filter
      if (filters.search.trim()) {
        const searchTerm = `%${filters.search.trim()}%`;
        // Search in order_number and pharmacy name
        q = q.or(
          `order_number.ilike.${searchTerm},pharmacy.name.ilike.${searchTerm}`
        );
      }

      const { data, error } = await q;

      if (error) {
        console.error('[useOrdersQuery] Error:', error);
        throw error;
      }

      // Transform and add computed fields
      return (data || []).map((order): OrderWithDetails => ({
        ...order,
        _itemCount: order.items?.length || 0,
      }));
    },
    getNextPageParam: (lastPage) => {
      if (lastPage.length < pageSize) return undefined;
      const lastOrder = lastPage[lastPage.length - 1];
      return lastOrder?.created_at;
    },
    enabled: !!patient?.id,
    staleTime: 30 * 1000, // 30 seconds
    gcTime: 5 * 60 * 1000, // 5 minutes
    initialPageParam: undefined as string | undefined,
  });

  // Real-time subscription for order updates
  useEffect(() => {
    if (!patient?.id) return;

    const channel = supabase
      .channel('orders-list-updates')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'orders',
          filter: `patient_id=eq.${patient.id}`,
        },
        (payload) => {
          // Invalidate queries to refetch
          queryClient.invalidateQueries({ queryKey: ['orders', patient.id] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [patient?.id, supabase, queryClient]);

  // Flatten pages for convenience
  const orders = useMemo(() => {
    return query.data?.pages.flat() ?? [];
  }, [query.data]);

  // Count orders by status (from first page, estimate)
  const statusCounts = useMemo(() => {
    const counts: Record<OrderFilterStatus, number> = {
      all: 0,
      active: 0,
      delivered: 0,
      cancelled: 0,
    };

    // This would ideally come from a separate count query
    // For now, estimate from loaded data
    orders.forEach((order) => {
      counts.all++;
      if (STATUS_GROUPS.active?.includes(order.status as OrderStatus)) {
        counts.active++;
      } else if (STATUS_GROUPS.delivered?.includes(order.status as OrderStatus)) {
        counts.delivered++;
      } else if (STATUS_GROUPS.cancelled?.includes(order.status as OrderStatus)) {
        counts.cancelled++;
      }
    });

    return counts;
  }, [orders]);

  return {
    orders,
    statusCounts,
    isLoading: query.isLoading,
    isFetchingNextPage: query.isFetchingNextPage,
    hasNextPage: query.hasNextPage,
    fetchNextPage: query.fetchNextPage,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  };
}
```

### Step 2: Reorder Service

Create `apps/patient/src/services/reorder-service.ts`:

```typescript
// ============================================================
// Reorder Service
// 
// Handles the complex logic of reordering from a previous order:
// - Check medication availability
// - Validate pharmacy status
// - Handle prescription requirements
// - Apply current pricing and limits
// ============================================================

import { getSupabaseClient } from '@/lib/supabase/client';
import type { Order, Medication, Pharmacy } from '@dawa/types';

// ─────────────────────────────────────────────────────────────
// TYPES
// ─────────────────────────────────────────────────────────────

export interface ReorderValidationResult {
  canReorder: boolean;
  
  // Pharmacy validation
  pharmacy: {
    isAvailable: boolean;
    reason?: 'closed' | 'inactive' | 'out_of_area';
  };
  
  // Items validation
  items: Array<{
    medicationId: string;
    medicationName: string;
    originalQuantity: number;
    adjustedQuantity: number;
    isAvailable: boolean;
    unavailableReason?: 'discontinued' | 'out_of_stock' | 'limit_exceeded';
    priceChange?: {
      original: number;
      current: number;
      percentChange: number;
    };
    alternatives?: Medication[];
  }>;
  
  // Prescription validation
  prescription: {
    required: boolean;
    hasValidPrescription: boolean;
    prescriptionExpired: boolean;
  };
  
  // Totals
  originalTotal: number;
  estimatedTotal: number;
  
  // Warnings to show user
  warnings: string[];
}

export interface ReorderCartResult {
  success: boolean;
  pharmacyId: string;
  items: Array<{
    medicationId: string;
    quantity: number;
    currentPrice: number;
  }>;
  requiresPrescription: boolean;
  warnings: string[];
}

// ─────────────────────────────────────────────────────────────
// VALIDATION
// ─────────────────────────────────────────────────────────────

export async function validateReorder(
  orderId: string
): Promise<ReorderValidationResult> {
  const supabase = getSupabaseClient();
  
  // Fetch original order with all details
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .select(`
      *,
      pharmacy:pharmacies (*),
      items:order_items (
        id,
        quantity,
        unit_price,
        medication:medications (*)
      ),
      prescription:prescriptions (*)
    `)
    .eq('id', orderId)
    .single();

  if (orderError || !order) {
    throw new Error('Order not found');
  }

  const result: ReorderValidationResult = {
    canReorder: true,
    pharmacy: { isAvailable: true },
    items: [],
    prescription: {
      required: false,
      hasValidPrescription: false,
      prescriptionExpired: false,
    },
    originalTotal: order.total_amount,
    estimatedTotal: 0,
    warnings: [],
  };

  // ─────────────────────────────────────────────────────────────
  // 1. VALIDATE PHARMACY
  // ─────────────────────────────────────────────────────────────
  
  const pharmacy = order.pharmacy as Pharmacy;
  
  if (pharmacy.status !== 'ACTIVE') {
    result.pharmacy = {
      isAvailable: false,
      reason: pharmacy.status === 'CLOSED' ? 'closed' : 'inactive',
    };
    result.canReorder = false;
    result.warnings.push(`${pharmacy.name} n'est plus disponible`);
  }

  // ─────────────────────────────────────────────────────────────
  // 2. VALIDATE EACH ITEM
  // ─────────────────────────────────────────────────────────────
  
  let requiresPrescription = false;
  let estimatedTotal = 0;

  for (const item of order.items) {
    const medication = item.medication as Medication;
    
    // Fetch current medication data
    const { data: currentMed } = await supabase
      .from('medications')
      .select('*')
      .eq('id', medication.id)
      .single();

    const itemResult: ReorderValidationResult['items'][0] = {
      medicationId: medication.id,
      medicationName: medication.name,
      originalQuantity: item.quantity,
      adjustedQuantity: item.quantity,
      isAvailable: true,
    };

    // Check if medication exists and is available
    if (!currentMed || !currentMed.is_available) {
      itemResult.isAvailable = false;
      itemResult.unavailableReason = 'discontinued';
      result.warnings.push(`${medication.name} n'est plus disponible`);
      
      // Find alternatives
      const { data: alternatives } = await supabase
        .from('medications')
        .select('*')
        .eq('category', medication.category)
        .eq('is_available', true)
        .limit(3);
      
      if (alternatives?.length) {
        itemResult.alternatives = alternatives as Medication[];
      }
    } else {
      // Check stock (if we track it)
      if (currentMed.stock_quantity !== null && currentMed.stock_quantity < item.quantity) {
        if (currentMed.stock_quantity === 0) {
          itemResult.isAvailable = false;
          itemResult.unavailableReason = 'out_of_stock';
          result.warnings.push(`${medication.name} est en rupture de stock`);
        } else {
          itemResult.adjustedQuantity = currentMed.stock_quantity;
          result.warnings.push(
            `${medication.name}: quantité ajustée de ${item.quantity} à ${currentMed.stock_quantity}`
          );
        }
      }

      // Check quantity limits
      if (currentMed.max_quantity_per_order && item.quantity > currentMed.max_quantity_per_order) {
        itemResult.adjustedQuantity = currentMed.max_quantity_per_order;
        itemResult.unavailableReason = 'limit_exceeded';
        result.warnings.push(
          `${medication.name}: max ${currentMed.max_quantity_per_order} par commande`
        );
      }

      // Check price change
      const priceChange = ((currentMed.price - item.unit_price) / item.unit_price) * 100;
      if (Math.abs(priceChange) > 10) {
        itemResult.priceChange = {
          original: item.unit_price,
          current: currentMed.price,
          percentChange: priceChange,
        };
        if (priceChange > 20) {
          result.warnings.push(
            `${medication.name}: prix augmenté de ${Math.round(priceChange)}%`
          );
        }
      }

      // Track prescription requirement
      if (currentMed.requires_prescription) {
        requiresPrescription = true;
      }

      // Calculate total
      if (itemResult.isAvailable) {
        estimatedTotal += currentMed.price * itemResult.adjustedQuantity;
      }
    }

    result.items.push(itemResult);
  }

  // ─────────────────────────────────────────────────────────────
  // 3. VALIDATE PRESCRIPTION
  // ─────────────────────────────────────────────────────────────
  
  result.prescription.required = requiresPrescription;
  
  if (requiresPrescription && order.prescription) {
    const prescription = order.prescription as any;
    const expiryDate = new Date(prescription.expiry_date);
    
    if (expiryDate > new Date()) {
      result.prescription.hasValidPrescription = true;
    } else {
      result.prescription.prescriptionExpired = true;
      result.warnings.push('Votre ordonnance a expiré. Une nouvelle ordonnance est requise.');
    }
  }

  // ─────────────────────────────────────────────────────────────
  // 4. FINALIZE
  // ─────────────────────────────────────────────────────────────

  // Add delivery fee
  estimatedTotal += 15; // Standard delivery fee
  result.estimatedTotal = estimatedTotal;

  // Check if any items available
  const availableItems = result.items.filter(i => i.isAvailable);
  if (availableItems.length === 0) {
    result.canReorder = false;
    result.warnings.push('Aucun article disponible pour recommander');
  }

  return result;
}

// ─────────────────────────────────────────────────────────────
// CREATE REORDER CART
// ─────────────────────────────────────────────────────────────

export async function createReorderCart(
  orderId: string,
  options: {
    includeUnavailable?: boolean; // Include items even if unavailable (for alternatives)
    newPharmacyId?: string; // If original pharmacy unavailable
  } = {}
): Promise<ReorderCartResult> {
  const validation = await validateReorder(orderId);
  
  // Get pharmacy ID (original or new)
  let pharmacyId = options.newPharmacyId;
  if (!pharmacyId) {
    const supabase = getSupabaseClient();
    const { data: order } = await supabase
      .from('orders')
      .select('pharmacy_id')
      .eq('id', orderId)
      .single();
    pharmacyId = order?.pharmacy_id;
  }

  if (!pharmacyId) {
    throw new Error('No pharmacy available for reorder');
  }

  // Build cart items
  const items = validation.items
    .filter(item => item.isAvailable || options.includeUnavailable)
    .map(item => ({
      medicationId: item.medicationId,
      quantity: item.adjustedQuantity,
      currentPrice: item.priceChange?.current || 0, // Would need to fetch
    }));

  return {
    success: items.length > 0,
    pharmacyId,
    items,
    requiresPrescription: validation.prescription.required && !validation.prescription.hasValidPrescription,
    warnings: validation.warnings,
  };
}
```

### Step 3: Orders List Page

Create `apps/patient/src/app/(main)/orders/page.tsx`:

```typescript
'use client';

// ============================================================
// Orders History Page
// 
// Features:
// - Filterable, searchable order list
// - Cursor-based infinite scroll
// - Quick reorder functionality
// - Status-based tabs
// ============================================================

import { useState, useMemo, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Search, Filter, X, Calendar, Download } from 'lucide-react';
import { useDebounce } from 'use-debounce';

import { useOrdersQuery, OrderFilters, OrderFilterStatus } from '@/hooks/useOrdersQuery';
import { OrderCard } from '@/components/features/orders/order-card';
import { OrderFilterTabs } from '@/components/features/orders/order-filter-tabs';
import { OrdersEmptyState } from '@/components/features/orders/orders-empty-state';
import { OrderCardSkeleton } from '@/components/features/orders/order-card-skeleton';
import { DateRangePicker } from '@/components/ui/date-range-picker';

// ─────────────────────────────────────────────────────────────
// COMPONENT
// ─────────────────────────────────────────────────────────────

export default function OrdersPage() {
  // Filter state
  const [searchInput, setSearchInput] = useState('');
  const [debouncedSearch] = useDebounce(searchInput, 300);
  const [statusFilter, setStatusFilter] = useState<OrderFilterStatus>('all');
  const [dateRange, setDateRange] = useState<{ from: Date | null; to: Date | null }>({
    from: null,
    to: null,
  });
  const [showFilters, setShowFilters] = useState(false);

  // Build filters object
  const filters: OrderFilters = useMemo(() => ({
    search: debouncedSearch,
    status: statusFilter,
    dateFrom: dateRange.from,
    dateTo: dateRange.to,
  }), [debouncedSearch, statusFilter, dateRange]);

  // Query orders
  const {
    orders,
    statusCounts,
    isLoading,
    isFetchingNextPage,
    hasNextPage,
    fetchNextPage,
    isError,
    refetch,
  } = useOrdersQuery({ filters });

  // Clear all filters
  const clearFilters = useCallback(() => {
    setSearchInput('');
    setStatusFilter('all');
    setDateRange({ from: null, to: null });
  }, []);

  // Check if any filters are active
  const hasActiveFilters = searchInput || statusFilter !== 'all' || dateRange.from || dateRange.to;

  return (
    <div className="page-container py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Mes commandes</h1>
          <p className="text-gray-600">Historique et suivi de vos commandes</p>
        </div>
        
        {/* Export button */}
        <button
          className="hidden sm:flex items-center gap-2 rounded-lg border border-gray-200 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
        >
          <Download className="h-4 w-4" />
          Exporter
        </button>
      </div>

      {/* Search and filter bar */}
      <div className="space-y-4">
        {/* Search input */}
        <div className="relative">
          <Search className="absolute left-4 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400" />
          <input
            type="text"
            value={searchInput}
            onChange={(e) => setSearchInput(e.target.value)}
            placeholder="Rechercher par numéro, pharmacie ou médicament..."
            className="w-full rounded-xl border border-gray-200 bg-white py-3 pl-12 pr-12
                     transition-all duration-200
                     focus:border-primary-500 focus:outline-none focus:ring-2 focus:ring-primary-500/20"
          />
          {searchInput && (
            <button
              onClick={() => setSearchInput('')}
              className="absolute right-4 top-1/2 -translate-y-1/2 p-1 rounded-full hover:bg-gray-100"
            >
              <X className="h-4 w-4 text-gray-400" />
            </button>
          )}
        </div>

        {/* Filter tabs */}
        <div className="flex items-center justify-between gap-4">
          <OrderFilterTabs
            activeFilter={statusFilter}
            onChange={setStatusFilter}
            counts={statusCounts}
          />
          
          {/* Advanced filters toggle */}
          <button
            onClick={() => setShowFilters(!showFilters)}
            className={`
              flex items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium
              transition-colors
              ${showFilters || dateRange.from
                ? 'bg-primary-50 text-primary-600'
                : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
              }
            `}
          >
            <Filter className="h-4 w-4" />
            Filtres
            {(dateRange.from || dateRange.to) && (
              <span className="flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs text-white">
                1
              </span>
            )}
          </button>
        </div>

        {/* Advanced filters panel */}
        <AnimatePresence>
          {showFilters && (
            <motion.div
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: 'auto', opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              className="overflow-hidden"
            >
              <div className="rounded-xl border border-gray-200 bg-white p-4">
                <div className="flex flex-wrap items-center gap-4">
                  <div className="flex items-center gap-2">
                    <Calendar className="h-4 w-4 text-gray-400" />
                    <span className="text-sm text-gray-600">Période:</span>
                  </div>
                  <DateRangePicker
                    from={dateRange.from}
                    to={dateRange.to}
                    onChange={setDateRange}
                  />
                  
                  {hasActiveFilters && (
                    <button
                      onClick={clearFilters}
                      className="ml-auto text-sm text-primary-600 hover:text-primary-700"
                    >
                      Effacer les filtres
                    </button>
                  )}
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Results */}
      <div className="space-y-4">
        {/* Loading state */}
        {isLoading ? (
          <div className="space-y-4">
            {[...Array(3)].map((_, i) => (
              <OrderCardSkeleton key={i} />
            ))}
          </div>
        ) : isError ? (
          // Error state
          <div className="rounded-xl border border-red-200 bg-red-50 p-6 text-center">
            <p className="text-red-600 mb-4">
              Erreur lors du chargement des commandes
            </p>
            <button
              onClick={() => refetch()}
              className="rounded-lg bg-red-600 px-4 py-2 text-sm font-medium text-white hover:bg-red-700"
            >
              Réessayer
            </button>
          </div>
        ) : orders.length === 0 ? (
          // Empty state
          <OrdersEmptyState
            hasFilters={hasActiveFilters}
            statusFilter={statusFilter}
            onClearFilters={clearFilters}
          />
        ) : (
          // Orders list
          <>
            {orders.map((order, index) => (
              <motion.div
                key={order.id}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: Math.min(index * 0.05, 0.3) }}
              >
                <OrderCard order={order} />
              </motion.div>
            ))}

            {/* Load more button */}
            {hasNextPage && (
              <div className="flex justify-center pt-4">
                <button
                  onClick={() => fetchNextPage()}
                  disabled={isFetchingNextPage}
                  className="rounded-xl bg-gray-100 px-8 py-3 text-sm font-medium text-gray-700
                           hover:bg-gray-200 disabled:opacity-50 transition-colors"
                >
                  {isFetchingNextPage ? (
                    <span className="flex items-center gap-2">
                      <span className="h-4 w-4 animate-spin rounded-full border-2 border-gray-400 border-t-transparent" />
                      Chargement...
                    </span>
                  ) : (
                    'Charger plus'
                  )}
                </button>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}
```

### Step 4: Order Card with Reorder

Create `apps/patient/src/components/features/orders/order-card.tsx`:

```typescript
'use client';

// ============================================================
// Order Card Component
// 
// Displays order summary with:
// - Status badge with semantic color
// - Items summary (first 2 + count)
// - Quick actions (track, reorder, details)
// ============================================================

import { useState, useCallback } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { motion } from 'framer-motion';
import { 
  MapPin, 
  ChevronRight, 
  RefreshCw, 
  Eye,
  Package,
  Clock,
  CheckCircle,
  XCircle,
  Truck,
  AlertCircle,
  Loader2,
} from 'lucide-react';
import { toast } from 'sonner';

import { useOrderStore } from '@/stores/order-store';
import { validateReorder, createReorderCart } from '@/services/reorder-service';
import { formatCurrency, formatRelativeTime } from '@dawa/utils';
import { ReorderWarningModal } from './reorder-warning-modal';
import type { OrderWithDetails } from '@/hooks/useOrdersQuery';
import type { OrderStatus } from '@dawa/types';

// ─────────────────────────────────────────────────────────────
// STATUS CONFIGURATION
// ─────────────────────────────────────────────────────────────

interface StatusConfig {
  label: string;
  icon: typeof Clock;
  bgColor: string;
  textColor: string;
  dotColor: string;
}

const STATUS_CONFIG: Record<OrderStatus, StatusConfig> = {
  DRAFT: { 
    label: 'Brouillon', 
    icon: Clock, 
    bgColor: 'bg-gray-100',
    textColor: 'text-gray-700',
    dotColor: 'bg-gray-500',
  },
  PENDING_PHARMACY: { 
    label: 'En attente', 
    icon: Clock, 
    bgColor: 'bg-yellow-100',
    textColor: 'text-yellow-700',
    dotColor: 'bg-yellow-500',
  },
  CONFIRMED: { 
    label: 'Confirmée', 
    icon: CheckCircle, 
    bgColor: 'bg-blue-100',
    textColor: 'text-blue-700',
    dotColor: 'bg-blue-500',
  },
  PREPARING: { 
    label: 'Préparation', 
    icon: Package, 
    bgColor: 'bg-blue-100',
    textColor: 'text-blue-700',
    dotColor: 'bg-blue-500',
  },
  READY_FOR_PICKUP: { 
    label: 'Prête', 
    icon: Package, 
    bgColor: 'bg-green-100',
    textColor: 'text-green-700',
    dotColor: 'bg-green-500',
  },
  ASSIGNED_TO_COURIER: { 
    label: 'Assignée', 
    icon: Truck, 
    bgColor: 'bg-blue-100',
    textColor: 'text-blue-700',
    dotColor: 'bg-blue-500',
  },
  COURIER_PICKED_UP: { 
    label: 'Collectée', 
    icon: Truck, 
    bgColor: 'bg-blue-100',
    textColor: 'text-blue-700',
    dotColor: 'bg-blue-500',
  },
  IN_TRANSIT: { 
    label: 'En livraison', 
    icon: Truck, 
    bgColor: 'bg-primary-100',
    textColor: 'text-primary-700',
    dotColor: 'bg-primary-500',
  },
  ARRIVED: { 
    label: 'Arrivé', 
    icon: Truck, 
    bgColor: 'bg-green-100',
    textColor: 'text-green-700',
    dotColor: 'bg-green-500',
  },
  DELIVERED: { 
    label: 'Livrée', 
    icon: CheckCircle, 
    bgColor: 'bg-green-100',
    textColor: 'text-green-700',
    dotColor: 'bg-green-500',
  },
  CANCELLED: { 
    label: 'Annulée', 
    icon: XCircle, 
    bgColor: 'bg-red-100',
    textColor: 'text-red-700',
    dotColor: 'bg-red-500',
  },
  RETURNED: { 
    label: 'Retournée', 
    icon: RefreshCw, 
    bgColor: 'bg-orange-100',
    textColor: 'text-orange-700',
    dotColor: 'bg-orange-500',
  },
  REFUNDED: { 
    label: 'Remboursée', 
    icon: CheckCircle, 
    bgColor: 'bg-gray-100',
    textColor: 'text-gray-700',
    dotColor: 'bg-gray-500',
  },
  FAILED_DELIVERY: { 
    label: 'Échec', 
    icon: AlertCircle, 
    bgColor: 'bg-red-100',
    textColor: 'text-red-700',
    dotColor: 'bg-red-500',
  },
};

// Statuses where tracking is relevant
const TRACKABLE_STATUSES: OrderStatus[] = [
  'PENDING_PHARMACY',
  'CONFIRMED',
  'PREPARING',
  'READY_FOR_PICKUP',
  'ASSIGNED_TO_COURIER',
  'COURIER_PICKED_UP',
  'IN_TRANSIT',
  'ARRIVED',
];

// Statuses where reorder is possible
const REORDERABLE_STATUSES: OrderStatus[] = [
  'DELIVERED',
  'CANCELLED',
  'RETURNED',
  'REFUNDED',
  'FAILED_DELIVERY',
];

// ─────────────────────────────────────────────────────────────
// COMPONENT
// ─────────────────────────────────────────────────────────────

interface OrderCardProps {
  order: OrderWithDetails;
}

export function OrderCard({ order }: OrderCardProps) {
  const router = useRouter();
  const { setPharmacy, addItem, clearCart } = useOrderStore();
  
  const [isReordering, setIsReordering] = useState(false);
  const [reorderWarnings, setReorderWarnings] = useState<string[] | null>(null);

  // Get status config
  const status = STATUS_CONFIG[order.status as OrderStatus] || STATUS_CONFIG.DRAFT;
  const StatusIcon = status.icon;

  // Check capabilities
  const canTrack = TRACKABLE_STATUSES.includes(order.status as OrderStatus);
  const canReorder = REORDERABLE_STATUSES.includes(order.status as OrderStatus);

  // Build items summary
  const itemsSummary = order.items
    .slice(0, 2)
    .map((i) => i.medication.name)
    .join(', ');
  const extraItemsCount = order._itemCount - 2;

  // ─────────────────────────────────────────────────────────────
  // REORDER HANDLER
  // ─────────────────────────────────────────────────────────────

  const handleReorder = useCallback(async () => {
    setIsReordering(true);

    try {
      // Validate reorder
      const validation = await validateReorder(order.id);

      if (!validation.canReorder) {
        toast.error('Impossible de recommander', {
          description: validation.warnings[0] || 'Une erreur est survenue',
        });
        return;
      }

      // Check for warnings
      if (validation.warnings.length > 0) {
        setReorderWarnings(validation.warnings);
        return; // Show modal
      }

      // No warnings - proceed directly
      await executeReorder();

    } catch (error) {
      console.error('Reorder error:', error);
      toast.error('Erreur lors de la recommande');
    } finally {
      setIsReordering(false);
    }
  }, [order.id]);

  const executeReorder = async () => {
    try {
      const result = await createReorderCart(order.id);

      if (!result.success) {
        toast.error('Impossible de créer la commande');
        return;
      }

      // Clear current cart
      clearCart();

      // Set pharmacy
      setPharmacy(order.pharmacy as any);

      // Add items to cart
      for (const item of result.items) {
        // Would need to fetch full medication data
        // For now, navigate to order flow with prefilled state
      }

      // Show success and navigate
      toast.success('Articles ajoutés au panier');
      
      // Navigate to order flow
      router.push('/orders/new?step=cart');

    } catch (error) {
      console.error('Execute reorder error:', error);
      toast.error('Erreur lors de la recommande');
    }
  };

  const handleConfirmReorder = async () => {
    setReorderWarnings(null);
    setIsReordering(true);
    await executeReorder();
    setIsReordering(false);
  };

  // ─────────────────────────────────────────────────────────────
  // RENDER
  // ─────────────────────────────────────────────────────────────

  return (
    <>
      <motion.div
        whileHover={{ y: -2 }}
        transition={{ duration: 0.2 }}
        className="rounded-2xl bg-white shadow-soft border border-gray-100 overflow-hidden"
      >
        {/* Main content - clickable to details */}
        <Link 
          href={`/orders/${order.id}`}
          className="block p-4 hover:bg-gray-50/50 transition-colors"
        >
          <div className="flex gap-4">
            {/* Pharmacy logo */}
            <div className="relative h-14 w-14 shrink-0 overflow-hidden rounded-xl bg-gray-100">
              {order.pharmacy.logo_url ? (
                <img
                  src={order.pharmacy.logo_url}
                  alt=""
                  className="h-full w-full object-cover"
                />
              ) : (
                <div className="flex h-full w-full items-center justify-center bg-gradient-to-br from-primary-100 to-primary-200">
                  <MapPin className="h-6 w-6 text-primary-600" />
                </div>
              )}
            </div>

            {/* Order info */}
            <div className="flex-1 min-w-0">
              <div className="flex items-start justify-between gap-2">
                <div className="min-w-0">
                  <h3 className="font-semibold text-gray-900 truncate">
                    {order.pharmacy.name}
                  </h3>
                  <p className="text-sm text-gray-500">#{order.order_number}</p>
                </div>
                
                {/* Status badge */}
                <div className={`
                  flex items-center gap-1.5 shrink-0 rounded-full px-2.5 py-1 text-xs font-medium
                  ${status.bgColor} ${status.textColor}
                `}>
                  <span className={`h-1.5 w-1.5 rounded-full ${status.dotColor}`} />
                  {status.label}
                </div>
              </div>

              {/* Items summary */}
              <p className="mt-2 text-sm text-gray-600 truncate">
                {itemsSummary}
                {extraItemsCount > 0 && (
                  <span className="text-gray-400"> +{extraItemsCount}</span>
                )}
              </p>

              {/* Price and date */}
              <div className="mt-2 flex items-center justify-between">
                <span className="font-semibold text-primary-600">
                  {formatCurrency(order.total_amount)}
                </span>
                <span className="text-xs text-gray-400">
                  {formatRelativeTime(new Date(order.created_at))}
                </span>
              </div>
            </div>

            <ChevronRight className="h-5 w-5 text-gray-400 shrink-0 self-center" />
          </div>
        </Link>

        {/* Action buttons */}
        <div className="flex border-t border-gray-100 divide-x divide-gray-100">
          {canTrack && (
            <Link
              href={`/orders/${order.id}`}
              className="flex flex-1 items-center justify-center gap-2 py-3 text-sm font-medium
                       text-primary-600 hover:bg-primary-50 transition-colors"
            >
              <Eye className="h-4 w-4" />
              Suivre
            </Link>
          )}
          
          {canReorder && (
            <button
              onClick={handleReorder}
              disabled={isReordering}
              className="flex flex-1 items-center justify-center gap-2 py-3 text-sm font-medium
                       text-gray-600 hover:bg-gray-50 transition-colors
                       disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isReordering ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <RefreshCw className="h-4 w-4" />
              )}
              Recommander
            </button>
          )}
          
          <Link
            href={`/orders/${order.id}`}
            className="flex flex-1 items-center justify-center gap-2 py-3 text-sm font-medium
                     text-gray-600 hover:bg-gray-50 transition-colors"
          >
            Détails
            <ChevronRight className="h-4 w-4" />
          </Link>
        </div>
      </motion.div>

      {/* Reorder warning modal */}
      {reorderWarnings && (
        <ReorderWarningModal
          warnings={reorderWarnings}
          onConfirm={handleConfirmReorder}
          onCancel={() => setReorderWarnings(null)}
          isLoading={isReordering}
        />
      )}
    </>
  );
}
```

---

## DATABASE SCHEMA ADDITIONS

```sql
-- ============================================================
-- ORDERS LIST OPTIMIZATION
-- ============================================================

-- Create index for patient orders list query
CREATE INDEX idx_orders_patient_created 
  ON orders(patient_id, created_at DESC);

-- Create index for status filtering
CREATE INDEX idx_orders_patient_status 
  ON orders(patient_id, status, created_at DESC);

-- Create full-text search index for medication names in orders
CREATE INDEX idx_order_items_medication_search 
  ON order_items USING GIN (to_tsvector('french', medication_name));

-- Function to get order counts by status for a patient
CREATE OR REPLACE FUNCTION get_patient_order_counts(p_patient_id UUID)
RETURNS TABLE (
  total_count BIGINT,
  active_count BIGINT,
  delivered_count BIGINT,
  cancelled_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE status IN (
      'PENDING_PHARMACY', 'CONFIRMED', 'PREPARING', 'READY_FOR_PICKUP',
      'ASSIGNED_TO_COURIER', 'COURIER_PICKED_UP', 'IN_TRANSIT', 'ARRIVED'
    )) as active_count,
    COUNT(*) FILTER (WHERE status = 'DELIVERED') as delivered_count,
    COUNT(*) FILTER (WHERE status IN (
      'CANCELLED', 'RETURNED', 'REFUNDED', 'FAILED_DELIVERY'
    )) as cancelled_count
  FROM orders
  WHERE patient_id = p_patient_id;
END;
$$ LANGUAGE plpgsql;
```

---

## SUCCESS CRITERIA

- [ ] Cursor-based infinite scroll pagination
- [ ] Search across order number, pharmacy, medications
- [ ] Filter tabs with accurate counts
- [ ] Date range filtering
- [ ] Reorder with availability validation
- [ ] Reorder warnings for price changes, unavailable items
- [ ] Skeleton loading states
- [ ] Empty states with clear actions
- [ ] Real-time updates to list when orders change
- [ ] Export functionality (PDF receipts, CSV)
- [ ] Accessible to screen readers
- [ ] Responsive on mobile

---

## NEXT STEP

After validation passes, proceed to:
→ `dawa-docs/prompts/phase-1/P1.8-pharmacy-discovery.md`

Reference documentation:
→ `dawa-docs/docs/DAWA_MASTER.md`
→ `dawa-docs/docs/phases/PHASE_1.md`
