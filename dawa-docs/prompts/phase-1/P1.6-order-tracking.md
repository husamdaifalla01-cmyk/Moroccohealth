# P1.6 â€” Order Tracking (V100)

## Prompt ID: P1.6
## Phase: 1 - Patient Web App
## Estimated Time: 8-10 hours
## Prerequisites: P1.5 complete

---

## STRATEGIC CONTEXT

### The Problem We're Actually Solving

A patient waiting for medication isn't waiting for a package. They may be:
- In physical pain, counting minutes until relief
- Anxious about a child's fever at 2 AM
- Managing a chronic condition with precise timing needs
- Elderly and dependent on this medication for daily function

**The tracking screen is not a feature. It is an anxiety management system.**

Every design decision must answer: "Does this reduce or increase the patient's stress?"

### Emotional Journey Mapping

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        PATIENT EMOTIONAL TIMELINE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  ORDER        WAITING      PHARMACY      PREPARING    COURIER      DELIVEREDâ”‚
â”‚  PLACED       ...          CONFIRMS      ...          IN TRANSIT   âœ“        â”‚
â”‚    â”‚            â”‚             â”‚            â”‚              â”‚         â”‚        â”‚
â”‚    â–¼            â–¼             â–¼            â–¼              â–¼         â–¼        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”    â”‚
â”‚  â”‚ ğŸ˜° â”‚      â”‚ ğŸ˜Ÿ â”‚        â”‚ ğŸ˜Œ â”‚       â”‚ ğŸ˜Š â”‚        â”‚ ğŸ¤© â”‚     â”‚ ğŸ˜„ â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                              â”‚
â”‚  ANXIETY     UNCERTAINTY    RELIEF       ANTICIPATION  EXCITEMENT  JOY      â”‚
â”‚  "Did it     "Are they     "Finally!"   "Almost       "I can      "Done!"  â”‚
â”‚   work?"      open?"                     ready!"       see them!"           â”‚
â”‚                                                                              â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•    â”‚
â”‚  HIGH ANXIETY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º LOW ANXIETY   â”‚
â”‚                                                                              â”‚
â”‚  DESIGN IMPLICATION: Over-communicate at HIGH ANXIETY points                â”‚
â”‚                      Reduce noise at LOW ANXIETY points                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Anxiety Points (Must Address)

| Moment | Patient Thinking | Design Response |
|--------|------------------|-----------------|
| Just ordered | "Did it go through?" | Immediate confirmation + order number |
| Waiting for pharmacy | "Are they even open? Did they see it?" | Show pharmacy response time average |
| Pharmacy preparing | "How long will this take?" | Progress indicator with time estimate |
| Courier assigned | "Who is this person?" | Courier photo, name, rating, vehicle |
| In transit | "Where exactly? How much longer?" | Live map + distance countdown |
| Courier arrived | "Are they at my door?" | Push notification + prominent call button |

---

## TECHNICAL ARCHITECTURE

### Real-time Strategy Decision

**Why Supabase Realtime over polling:**

| Factor | Polling (30s) | Realtime WebSocket |
|--------|---------------|-------------------|
| Latency | 0-30s delay | <1s delay |
| Battery | Constant network requests | Idle connection |
| Server load | N requests/minute/user | 1 connection/user |
| UX perception | "Refreshing..." | "It's live" |
| Cost at scale | Higher (more API calls) | Lower (persistent connection) |

**Decision: Realtime primary, polling fallback**

### Connection State Machine

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CONNECTION STATE MACHINE                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ CONNECTED  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚                    â”‚         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚                       â”‚
â”‚                    â”‚ success       â”‚ disconnect     â”‚ success               â”‚
â”‚                    â”‚               â–¼                â”‚                       â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   Initialâ”€â”€â”€â–ºâ”‚CONNECTING â”‚   â”‚RECONNECTINGâ”‚   â”‚  FALLBACK  â”‚               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â”‚  POLLING   â”‚               â”‚
â”‚                    â”‚ failure       â”‚ max      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                    â”‚               â”‚ retries        â–²                       â”‚
â”‚                    â”‚               â–¼                â”‚                       â”‚
â”‚                    â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚                       â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   ERROR    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   manual retry                 â”‚
â”‚                                                                              â”‚
â”‚  TRANSITIONS:                                                               â”‚
â”‚  - CONNECTING â†’ CONNECTED: WebSocket opens successfully                     â”‚
â”‚  - CONNECTING â†’ ERROR: Initial connection fails                            â”‚
â”‚  - CONNECTED â†’ RECONNECTING: Connection drops unexpectedly                 â”‚
â”‚  - RECONNECTING â†’ CONNECTED: Reconnect succeeds                            â”‚
â”‚  - RECONNECTING â†’ FALLBACK_POLLING: Max retries (5) exceeded               â”‚
â”‚  - FALLBACK_POLLING â†’ CONNECTING: Manual retry or network recovery         â”‚
â”‚  - Any state â†’ DISCONNECTED: App backgrounded (save battery)               â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Morocco-Specific Map Challenges

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     MOROCCO DELIVERY REALITIES                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  CHALLENGE 1: NON-STANDARDIZED ADDRESSES                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  Morocco doesn't have standardized addresses in many areas, especially      â”‚
â”‚  medinas (old city quarters).                                               â”‚
â”‚                                                                              â”‚
â”‚  âŒ WRONG ASSUMPTION: "123 Rue Hassan II, Apt 4B, Casablanca"              â”‚
â”‚  âœ“ REALITY: "Near Bab Boujloud, the blue door next to carpet shop Aziz"   â”‚
â”‚                                                                              â”‚
â”‚  DESIGN SOLUTION:                                                           â”‚
â”‚  1. Patient drops a pin on map during address setup                         â”‚
â”‚  2. Patient uploads photo of building entrance                              â”‚
â”‚  3. Patient adds landmark description (free text)                           â”‚
â”‚  4. Courier sees all three: pin + photo + description                       â”‚
â”‚                                                                              â”‚
â”‚  CHALLENGE 2: GPS ACCURACY IN DENSE AREAS                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  - Medina walls cause GPS signal bounce (Â±50m error common)                â”‚
â”‚  - Narrow alleys = poor satellite visibility                                â”‚
â”‚  - Indoor pharmacies = GPS may show adjacent street                         â”‚
â”‚                                                                              â”‚
â”‚  DESIGN SOLUTION:                                                           â”‚
â”‚  1. Snap courier position to road network (not raw GPS)                     â”‚
â”‚  2. Show "on route" not exact position when accuracy <20m                   â”‚
â”‚  3. Use geofencing (100m radius) for "arrived" detection                    â”‚
â”‚  4. Always allow manual "I'm here" button for courier                       â”‚
â”‚                                                                              â”‚
â”‚  CHALLENGE 3: UNRELIABLE ETA                                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  - Google/Mapbox routes often wrong for Moroccan side streets              â”‚
â”‚  - Traffic data less reliable than EU/US                                    â”‚
â”‚  - One-way street data incomplete                                           â”‚
â”‚                                                                              â”‚
â”‚  DESIGN SOLUTION:                                                           â”‚
â”‚  1. Never show exact ETA - always ranges: "10-15 min"                       â”‚
â”‚  2. Under-promise, over-deliver: Add 20% buffer to estimate                 â”‚
â”‚  3. Show distance ("1.2 km away") which is verifiable                       â”‚
â”‚  4. Cache common pharmacyâ†’zone routes server-side                           â”‚
â”‚                                                                              â”‚
â”‚  CHALLENGE 4: MAP COSTS AT SCALE                                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  - Google Maps: ~$7 per 1,000 map loads (dynamic)                          â”‚
â”‚  - 10,000 daily active tracking sessions = $2,100/month maps alone         â”‚
â”‚                                                                              â”‚
â”‚  DESIGN SOLUTION:                                                           â”‚
â”‚  1. Use Mapbox GL JS (free tier: 50,000 loads/month)                       â”‚
â”‚  2. Static map image for orders NOT in transit                              â”‚
â”‚  3. Dynamic map ONLY during IN_TRANSIT and ARRIVED states                   â”‚
â”‚  4. Cache route polylines to avoid repeated API calls                       â”‚
â”‚  5. Lazy-load map component (not on initial page load)                      â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## IMPLEMENTATION

### Step 1: Connection Manager (Core Infrastructure)

Create `apps/patient/src/lib/realtime/connection-manager.ts`:

```typescript
// ============================================================
// Real-time Connection Manager
// 
// Responsibilities:
// 1. Manage WebSocket lifecycle (connect, disconnect, reconnect)
// 2. Handle connection state transitions
// 3. Implement exponential backoff for reconnection
// 4. Fall back to polling when WebSocket unavailable
// 5. Optimize battery by disconnecting when app backgrounded
// ============================================================

import { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';
import { getSupabaseClient } from '@/lib/supabase/client';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TYPES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export type ConnectionState = 
  | 'CONNECTING'       // Initial connection attempt in progress
  | 'CONNECTED'        // WebSocket open, receiving updates
  | 'RECONNECTING'     // Lost connection, auto-retry in progress
  | 'DISCONNECTED'     // Intentional disconnect (app backgrounded)
  | 'FALLBACK_POLLING' // WebSocket failed, using HTTP polling
  | 'ERROR';           // Unrecoverable error state

export interface ConnectionManagerConfig {
  maxReconnectAttempts: number;  // How many times to retry before falling back
  baseReconnectDelayMs: number;  // Initial delay between retries
  maxReconnectDelayMs: number;   // Maximum delay (cap for exponential backoff)
  pollingIntervalMs: number;     // Interval for fallback polling
  onStateChange?: (state: ConnectionState, previousState: ConnectionState) => void;
  onError?: (error: Error, context: string) => void;
}

export interface RealtimeUpdate {
  type: 'ORDER_UPDATE' | 'LOCATION_UPDATE' | 'STATUS_CHANGE';
  data: Record<string, any>;
  timestamp: string;
  source: 'realtime' | 'polling';
}

type UpdateCallback = (update: RealtimeUpdate) => void;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DEFAULT CONFIGURATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const DEFAULT_CONFIG: ConnectionManagerConfig = {
  maxReconnectAttempts: 5,
  baseReconnectDelayMs: 1000,    // Start with 1 second
  maxReconnectDelayMs: 30000,   // Cap at 30 seconds
  pollingIntervalMs: 30000,     // Poll every 30 seconds in fallback
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONNECTION MANAGER CLASS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export class ConnectionManager {
  private supabase = getSupabaseClient();
  private config: ConnectionManagerConfig;
  
  // Connection state
  private state: ConnectionState = 'DISCONNECTED';
  private channel: RealtimeChannel | null = null;
  private reconnectAttempts = 0;
  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null;
  private pollingInterval: ReturnType<typeof setInterval> | null = null;
  
  // Subscriptions
  private subscribers: Map<string, UpdateCallback> = new Map();
  private activeOrderId: string | null = null;
  
  // Visibility handling
  private visibilityHandler: (() => void) | null = null;
  private wasConnectedBeforeHidden = false;

  constructor(config: Partial<ConnectionManagerConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.setupVisibilityHandler();
    this.setupOnlineHandler();
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PUBLIC API
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Subscribe to real-time updates for an order
   * Returns unsubscribe function
   */
  subscribe(orderId: string, callback: UpdateCallback): () => void {
    // Store subscription
    this.subscribers.set(orderId, callback);
    this.activeOrderId = orderId;
    
    // Start connection if not already connected
    if (this.state === 'DISCONNECTED') {
      this.connect(orderId);
    } else if (this.state === 'CONNECTED' && this.channel) {
      // Already connected to different order - reconnect
      this.disconnect();
      this.connect(orderId);
    }

    // Return unsubscribe function
    return () => {
      this.subscribers.delete(orderId);
      if (this.subscribers.size === 0) {
        this.disconnect();
      }
    };
  }

  /**
   * Get current connection state
   */
  getState(): ConnectionState {
    return this.state;
  }

  /**
   * Force a reconnection attempt (user-initiated)
   */
  forceReconnect(): void {
    if (this.state === 'FALLBACK_POLLING' || this.state === 'ERROR') {
      this.reconnectAttempts = 0;  // Reset counter
      if (this.activeOrderId) {
        this.stopPolling();
        this.connect(this.activeOrderId);
      }
    }
  }

  /**
   * Clean up all resources
   */
  destroy(): void {
    this.disconnect();
    this.removeVisibilityHandler();
    this.removeOnlineHandler();
    this.subscribers.clear();
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CONNECTION LIFECYCLE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private async connect(orderId: string): Promise<void> {
    this.setState('CONNECTING');

    try {
      // Create channel with unique name
      const channelName = `order-tracking:${orderId}:${Date.now()}`;
      
      this.channel = this.supabase.channel(channelName, {
        config: {
          presence: { key: orderId },
        },
      });

      // Subscribe to order table changes
      this.channel.on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'orders',
          filter: `id=eq.${orderId}`,
        },
        (payload) => this.handleOrderUpdate(payload)
      );

      // Subscribe to courier location changes
      this.channel.on(
        'postgres_changes',
        {
          event: '*',  // INSERT and UPDATE
          schema: 'public',
          table: 'courier_locations',
          filter: `order_id=eq.${orderId}`,
        },
        (payload) => this.handleLocationUpdate(payload)
      );

      // Subscribe to status history changes (for timeline)
      this.channel.on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'order_status_history',
          filter: `order_id=eq.${orderId}`,
        },
        (payload) => this.handleStatusHistoryUpdate(payload)
      );

      // Handle subscription status
      this.channel.subscribe((status, err) => {
        if (status === 'SUBSCRIBED') {
          this.setState('CONNECTED');
          this.reconnectAttempts = 0;
          this.stopPolling();
        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
          this.handleConnectionError(
            err || new Error(`Channel ${status}`),
            'subscription'
          );
        } else if (status === 'CLOSED') {
          // Unexpected close - attempt reconnect
          if (this.state === 'CONNECTED') {
            this.handleConnectionError(
              new Error('Channel closed unexpectedly'),
              'channel_close'
            );
          }
        }
      });

    } catch (error) {
      this.handleConnectionError(error as Error, 'connect');
    }
  }

  private disconnect(): void {
    // Clear timers
    this.clearReconnectTimeout();
    this.stopPolling();

    // Remove channel
    if (this.channel) {
      this.supabase.removeChannel(this.channel);
      this.channel = null;
    }

    this.setState('DISCONNECTED');
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // UPDATE HANDLERS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private handleOrderUpdate(payload: RealtimePostgresChangesPayload<any>): void {
    const update: RealtimeUpdate = {
      type: 'ORDER_UPDATE',
      data: payload.new,
      timestamp: new Date().toISOString(),
      source: 'realtime',
    };

    this.notifySubscribers(update);
  }

  private handleLocationUpdate(payload: RealtimePostgresChangesPayload<any>): void {
    const update: RealtimeUpdate = {
      type: 'LOCATION_UPDATE',
      data: {
        latitude: payload.new.latitude,
        longitude: payload.new.longitude,
        heading: payload.new.heading,
        speed: payload.new.speed,
        accuracy: payload.new.accuracy,
        recordedAt: payload.new.recorded_at,
      },
      timestamp: new Date().toISOString(),
      source: 'realtime',
    };

    this.notifySubscribers(update);
  }

  private handleStatusHistoryUpdate(payload: RealtimePostgresChangesPayload<any>): void {
    const update: RealtimeUpdate = {
      type: 'STATUS_CHANGE',
      data: {
        status: payload.new.status,
        notes: payload.new.notes,
        changedAt: payload.new.created_at,
      },
      timestamp: new Date().toISOString(),
      source: 'realtime',
    };

    this.notifySubscribers(update);
  }

  private notifySubscribers(update: RealtimeUpdate): void {
    for (const callback of this.subscribers.values()) {
      try {
        callback(update);
      } catch (error) {
        console.error('Subscriber callback error:', error);
      }
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ERROR HANDLING & RECONNECTION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private handleConnectionError(error: Error, context: string): void {
    // Notify error handler
    this.config.onError?.(error, context);

    // Check if we should retry
    if (this.reconnectAttempts < this.config.maxReconnectAttempts) {
      this.setState('RECONNECTING');
      this.reconnectAttempts++;

      // Calculate delay with exponential backoff + jitter
      const exponentialDelay = this.config.baseReconnectDelayMs * 
        Math.pow(2, this.reconnectAttempts - 1);
      const jitter = Math.random() * 1000;  // 0-1000ms random jitter
      const delay = Math.min(
        exponentialDelay + jitter,
        this.config.maxReconnectDelayMs
      );

      console.log(
        `[ConnectionManager] Reconnect attempt ${this.reconnectAttempts}/${this.config.maxReconnectAttempts} in ${Math.round(delay)}ms`
      );

      // Schedule reconnect
      this.reconnectTimeout = setTimeout(() => {
        if (this.activeOrderId && this.state === 'RECONNECTING') {
          // Clean up old channel first
          if (this.channel) {
            this.supabase.removeChannel(this.channel);
            this.channel = null;
          }
          this.connect(this.activeOrderId);
        }
      }, delay);

    } else {
      // Max retries exceeded - fall back to polling
      console.log('[ConnectionManager] Max retries exceeded, falling back to polling');
      this.setState('FALLBACK_POLLING');
      this.startPolling();
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // POLLING FALLBACK
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private startPolling(): void {
    if (this.pollingInterval || !this.activeOrderId) return;

    const poll = async () => {
      if (!this.activeOrderId) return;

      try {
        // Fetch current order state
        const { data: order, error: orderError } = await this.supabase
          .from('orders')
          .select('*, courier:couriers(*)')
          .eq('id', this.activeOrderId)
          .single();

        if (orderError) throw orderError;

        if (order) {
          this.notifySubscribers({
            type: 'ORDER_UPDATE',
            data: order,
            timestamp: new Date().toISOString(),
            source: 'polling',
          });

          // Only fetch location if order is in transit
          if (['IN_TRANSIT', 'ARRIVED', 'COURIER_PICKED_UP'].includes(order.status)) {
            const { data: location } = await this.supabase
              .from('courier_locations')
              .select('*')
              .eq('order_id', this.activeOrderId)
              .order('recorded_at', { ascending: false })
              .limit(1)
              .single();

            if (location) {
              this.notifySubscribers({
                type: 'LOCATION_UPDATE',
                data: location,
                timestamp: new Date().toISOString(),
                source: 'polling',
              });
            }
          }
        }
      } catch (error) {
        console.error('[ConnectionManager] Polling error:', error);
      }
    };

    // Poll immediately, then on interval
    poll();
    this.pollingInterval = setInterval(poll, this.config.pollingIntervalMs);
  }

  private stopPolling(): void {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE MANAGEMENT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private setState(newState: ConnectionState): void {
    const previousState = this.state;
    if (previousState !== newState) {
      this.state = newState;
      this.config.onStateChange?.(newState, previousState);
    }
  }

  private clearReconnectTimeout(): void {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // VISIBILITY & ONLINE HANDLERS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private setupVisibilityHandler(): void {
    if (typeof document === 'undefined') return;

    this.visibilityHandler = () => {
      if (document.visibilityState === 'visible') {
        // App came to foreground
        if (this.wasConnectedBeforeHidden && this.activeOrderId) {
          console.log('[ConnectionManager] App foregrounded, reconnecting...');
          this.connect(this.activeOrderId);
        }
      } else {
        // App going to background - disconnect to save battery
        this.wasConnectedBeforeHidden = this.state === 'CONNECTED';
        if (this.state === 'CONNECTED' || this.state === 'RECONNECTING') {
          console.log('[ConnectionManager] App backgrounded, disconnecting...');
          this.disconnect();
        }
      }
    };

    document.addEventListener('visibilitychange', this.visibilityHandler);
  }

  private removeVisibilityHandler(): void {
    if (this.visibilityHandler && typeof document !== 'undefined') {
      document.removeEventListener('visibilitychange', this.visibilityHandler);
      this.visibilityHandler = null;
    }
  }

  private onlineHandler: (() => void) | null = null;

  private setupOnlineHandler(): void {
    if (typeof window === 'undefined') return;

    this.onlineHandler = () => {
      if (navigator.onLine && this.state === 'FALLBACK_POLLING') {
        console.log('[ConnectionManager] Network restored, attempting WebSocket...');
        this.forceReconnect();
      }
    };

    window.addEventListener('online', this.onlineHandler);
  }

  private removeOnlineHandler(): void {
    if (this.onlineHandler && typeof window !== 'undefined') {
      window.removeEventListener('online', this.onlineHandler);
      this.onlineHandler = null;
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SINGLETON INSTANCE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let instance: ConnectionManager | null = null;

export function getConnectionManager(
  config?: Partial<ConnectionManagerConfig>
): ConnectionManager {
  if (!instance) {
    instance = new ConnectionManager(config);
  }
  return instance;
}

export function resetConnectionManager(): void {
  if (instance) {
    instance.destroy();
    instance = null;
  }
}
```

### Step 2: Order Tracking Hook

Create `apps/patient/src/hooks/useOrderTracking.ts`:

```typescript
// ============================================================
// useOrderTracking Hook
// 
// Provides a clean React interface for order tracking:
// - Real-time order status updates
// - Live courier location during delivery
// - Connection state awareness
// - Toast notifications for status changes
// ============================================================

import { useEffect, useState, useCallback, useRef } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';

import { 
  getConnectionManager, 
  ConnectionManager,
  ConnectionState,
  RealtimeUpdate,
} from '@/lib/realtime/connection-manager';
import type { Order, OrderStatus } from '@dawa/types';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TYPES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface CourierLocation {
  latitude: number;
  longitude: number;
  heading: number | null;
  speed: number | null;
  accuracy: number | null;
  recordedAt: string;
}

interface UseOrderTrackingOptions {
  /**
   * Show toast notifications for status changes
   * @default true
   */
  showNotifications?: boolean;
  
  /**
   * Callback when order status changes
   */
  onStatusChange?: (newStatus: OrderStatus, previousStatus: OrderStatus) => void;
}

interface UseOrderTrackingResult {
  // Data
  order: Order | null;
  courierLocation: CourierLocation | null;
  
  // Connection
  connectionState: ConnectionState;
  isLive: boolean;  // True only when WebSocket connected
  isOnline: boolean; // True when connected OR polling
  
  // Derived state
  isDeliveryActive: boolean;
  canTrackCourier: boolean;
  
  // Actions
  refresh: () => Promise<void>;
  forceReconnect: () => void;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STATUS NOTIFICATION MESSAGES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const STATUS_NOTIFICATIONS: Partial<Record<OrderStatus, {
  title: string;
  description: string;
  type: 'success' | 'info' | 'warning';
}>> = {
  CONFIRMED: {
    title: 'Commande confirmÃ©e âœ“',
    description: 'La pharmacie prÃ©pare votre commande',
    type: 'success',
  },
  PREPARING: {
    title: 'En prÃ©paration',
    description: 'Vos mÃ©dicaments sont en cours de prÃ©paration',
    type: 'info',
  },
  READY_FOR_PICKUP: {
    title: 'Commande prÃªte !',
    description: 'Un livreur va Ãªtre assignÃ© sous peu',
    type: 'success',
  },
  ASSIGNED_TO_COURIER: {
    title: 'Livreur assignÃ©',
    description: 'Votre livreur se dirige vers la pharmacie',
    type: 'info',
  },
  COURIER_PICKED_UP: {
    title: 'Commande rÃ©cupÃ©rÃ©e',
    description: 'Le livreur a votre commande, il arrive !',
    type: 'success',
  },
  IN_TRANSIT: {
    title: 'En route vers vous ğŸ›µ',
    description: 'Suivez votre livreur en temps rÃ©el',
    type: 'info',
  },
  ARRIVED: {
    title: 'Livreur arrivÃ© ! ğŸ“',
    description: 'Votre livreur est Ã  votre adresse',
    type: 'success',
  },
  DELIVERED: {
    title: 'Commande livrÃ©e âœ“',
    description: 'Merci pour votre confiance !',
    type: 'success',
  },
  CANCELLED: {
    title: 'Commande annulÃ©e',
    description: 'Votre commande a Ã©tÃ© annulÃ©e',
    type: 'warning',
  },
  FAILED_DELIVERY: {
    title: 'Ã‰chec de livraison',
    description: 'La livraison n\'a pas pu Ãªtre effectuÃ©e',
    type: 'warning',
  },
};

// Statuses where courier tracking is relevant
const DELIVERY_ACTIVE_STATUSES: OrderStatus[] = [
  'ASSIGNED_TO_COURIER',
  'COURIER_PICKED_UP',
  'IN_TRANSIT',
  'ARRIVED',
];

// Statuses where we show the map with courier position
const COURIER_TRACKABLE_STATUSES: OrderStatus[] = [
  'COURIER_PICKED_UP',
  'IN_TRANSIT',
  'ARRIVED',
];

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HOOK IMPLEMENTATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function useOrderTracking(
  orderId: string,
  initialOrder?: Order,
  options: UseOrderTrackingOptions = {}
): UseOrderTrackingResult {
  const { showNotifications = true, onStatusChange } = options;
  
  // State
  const [order, setOrder] = useState<Order | null>(initialOrder || null);
  const [courierLocation, setCourierLocation] = useState<CourierLocation | null>(null);
  const [connectionState, setConnectionState] = useState<ConnectionState>('DISCONNECTED');
  
  // Refs for callbacks
  const previousStatusRef = useRef<OrderStatus | null>(
    (initialOrder?.status as OrderStatus) || null
  );
  const connectionManagerRef = useRef<ConnectionManager | null>(null);
  const queryClient = useQueryClient();

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DERIVED STATE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const isLive = connectionState === 'CONNECTED';
  const isOnline = connectionState === 'CONNECTED' || connectionState === 'FALLBACK_POLLING';
  
  const isDeliveryActive = order 
    ? DELIVERY_ACTIVE_STATUSES.includes(order.status as OrderStatus)
    : false;
    
  const canTrackCourier = order
    ? COURIER_TRACKABLE_STATUSES.includes(order.status as OrderStatus)
    : false;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // UPDATE HANDLER
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const handleUpdate = useCallback((update: RealtimeUpdate) => {
    switch (update.type) {
      case 'ORDER_UPDATE':
      case 'STATUS_CHANGE': {
        const newOrder = update.data as Order;
        const newStatus = newOrder.status as OrderStatus;
        const previousStatus = previousStatusRef.current;
        
        // Update order state
        setOrder(newOrder);
        
        // Handle status change
        if (previousStatus && newStatus !== previousStatus) {
          // Show notification
          if (showNotifications) {
            const notification = STATUS_NOTIFICATIONS[newStatus];
            if (notification) {
              toast[notification.type](notification.title, {
                description: notification.description,
              });
            }
          }
          
          // Trigger callback
          onStatusChange?.(newStatus, previousStatus);
          
          // Clear courier location if order completed/cancelled
          if (['DELIVERED', 'CANCELLED', 'FAILED_DELIVERY', 'RETURNED'].includes(newStatus)) {
            setCourierLocation(null);
          }
        }
        
        previousStatusRef.current = newStatus;
        
        // Invalidate React Query cache
        queryClient.invalidateQueries({ queryKey: ['order', orderId] });
        break;
      }
      
      case 'LOCATION_UPDATE': {
        const location = update.data as CourierLocation;
        setCourierLocation({
          latitude: location.latitude,
          longitude: location.longitude,
          heading: location.heading,
          speed: location.speed,
          accuracy: location.accuracy,
          recordedAt: location.recordedAt || update.timestamp,
        });
        break;
      }
    }
  }, [orderId, queryClient, showNotifications, onStatusChange]);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CONNECTION STATE HANDLER
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const handleConnectionStateChange = useCallback(
    (state: ConnectionState, previousState: ConnectionState) => {
      setConnectionState(state);
      
      // Show connection state feedback
      if (state === 'RECONNECTING' && previousState === 'CONNECTED') {
        toast.loading('Reconnexion en cours...', { id: 'connection-toast' });
      } else if (state === 'CONNECTED' && previousState === 'RECONNECTING') {
        toast.dismiss('connection-toast');
        toast.success('Connexion rÃ©tablie', { duration: 2000 });
      } else if (state === 'FALLBACK_POLLING') {
        toast.dismiss('connection-toast');
        toast.info('Mode hors-ligne activÃ©', {
          description: 'Mise Ã  jour toutes les 30 secondes',
          duration: 4000,
        });
      }
    },
    []
  );

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SUBSCRIPTION SETUP
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  useEffect(() => {
    // Get or create connection manager
    const manager = getConnectionManager({
      onStateChange: handleConnectionStateChange,
      onError: (error, context) => {
        console.error(`[useOrderTracking] Error in ${context}:`, error);
      },
    });
    connectionManagerRef.current = manager;

    // Subscribe to updates
    const unsubscribe = manager.subscribe(orderId, handleUpdate);

    // Cleanup on unmount
    return () => {
      unsubscribe();
    };
  }, [orderId, handleUpdate, handleConnectionStateChange]);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ACTIONS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const refresh = useCallback(async () => {
    const supabase = (await import('@/lib/supabase/client')).getSupabaseClient();
    
    const { data, error } = await supabase
      .from('orders')
      .select('*, courier:couriers(*)')
      .eq('id', orderId)
      .single();
    
    if (!error && data) {
      setOrder(data as Order);
      previousStatusRef.current = data.status as OrderStatus;
    }
  }, [orderId]);

  const forceReconnect = useCallback(() => {
    connectionManagerRef.current?.forceReconnect();
  }, []);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // RETURN
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  return {
    order,
    courierLocation,
    connectionState,
    isLive,
    isOnline,
    isDeliveryActive,
    canTrackCourier,
    refresh,
    forceReconnect,
  };
}
```

### Step 3: Tracking Map Component

Create `apps/patient/src/components/features/tracking/tracking-map.tsx`:

```typescript
'use client';

// ============================================================
// Tracking Map Component
// 
// Displays:
// - Pharmacy location (origin)
// - Delivery location (destination)  
// - Courier position (real-time during transit)
// - Route visualization
// 
// Performance optimizations:
// - Lazy load Mapbox GL
// - Smooth marker animations
// - Efficient re-renders
// ============================================================

import { useEffect, useRef, useState, memo, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import dynamic from 'next/dynamic';

import { MapPin, Navigation, Home, Loader2, AlertCircle, RefreshCw } from 'lucide-react';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TYPES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface LatLng {
  lat: number;
  lng: number;
}

interface CourierPosition extends LatLng {
  heading: number | null;
  accuracy: number | null;
}

interface TrackingMapProps {
  pharmacyLocation: LatLng;
  deliveryLocation: LatLng;
  courierPosition: CourierPosition | null;
  isLive: boolean;
  className?: string;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MAP COMPONENT (LAZY LOADED)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Lazy load the actual map implementation to reduce initial bundle
const MapboxMap = dynamic(
  () => import('./mapbox-map-impl').then(mod => mod.MapboxMapImpl),
  {
    loading: () => <MapLoadingState />,
    ssr: false, // Mapbox requires browser APIs
  }
);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MAIN COMPONENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export const TrackingMap = memo(function TrackingMap({
  pharmacyLocation,
  deliveryLocation,
  courierPosition,
  isLive,
  className = '',
}: TrackingMapProps) {
  const [mapError, setMapError] = useState<string | null>(null);
  const [isMapReady, setIsMapReady] = useState(false);

  // Handle map initialization errors
  const handleMapError = useCallback((error: Error) => {
    console.error('[TrackingMap] Error:', error);
    setMapError('Impossible de charger la carte');
  }, []);

  // Handle map ready
  const handleMapReady = useCallback(() => {
    setIsMapReady(true);
  }, []);

  // Retry loading map
  const handleRetry = useCallback(() => {
    setMapError(null);
    setIsMapReady(false);
  }, []);

  // Error state
  if (mapError) {
    return (
      <MapErrorState 
        message={mapError} 
        onRetry={handleRetry} 
      />
    );
  }

  return (
    <div 
      className={`
        relative overflow-hidden rounded-2xl border border-gray-200 
        shadow-soft bg-gray-100 ${className}
      `}
    >
      {/* Map */}
      <div className="h-64 md:h-80">
        <MapboxMap
          pharmacyLocation={pharmacyLocation}
          deliveryLocation={deliveryLocation}
          courierPosition={courierPosition}
          onError={handleMapError}
          onReady={handleMapReady}
        />
      </div>

      {/* Live indicator overlay */}
      <AnimatePresence>
        {isLive && isMapReady && (
          <motion.div
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.8 }}
            className="absolute top-3 left-3 z-10"
          >
            <div className="flex items-center gap-2 rounded-full bg-white/95 backdrop-blur-sm px-3 py-1.5 shadow-lg">
              <span className="relative flex h-2 w-2">
                <span className="absolute inline-flex h-full w-full animate-ping rounded-full bg-green-400 opacity-75" />
                <span className="relative inline-flex h-2 w-2 rounded-full bg-green-500" />
              </span>
              <span className="text-xs font-medium text-gray-700">En direct</span>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Legend overlay */}
      <div className="absolute bottom-3 left-3 right-3 z-10">
        <div className="flex items-center justify-between rounded-xl bg-white/95 backdrop-blur-sm px-4 py-2.5 shadow-lg">
          <div className="flex items-center gap-4 text-xs">
            <LegendItem 
              icon={<MapPin className="h-3 w-3 text-primary-600" />}
              label="Pharmacie"
            />
            <LegendItem
              icon={<Home className="h-3 w-3 text-green-600" />}
              label="Livraison"
            />
            {courierPosition && (
              <LegendItem
                icon={<Navigation className="h-3 w-3 text-primary-500" />}
                label="Livreur"
              />
            )}
          </div>

          {/* ETA display would go here - calculated from route */}
        </div>
      </div>
    </div>
  );
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SUB-COMPONENTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function LegendItem({ icon, label }: { icon: React.ReactNode; label: string }) {
  return (
    <div className="flex items-center gap-1.5">
      <div className="flex h-5 w-5 items-center justify-center rounded-full bg-gray-100">
        {icon}
      </div>
      <span className="text-gray-600">{label}</span>
    </div>
  );
}

function MapLoadingState() {
  return (
    <div className="flex h-full items-center justify-center bg-gray-100">
      <div className="flex flex-col items-center gap-3">
        <Loader2 className="h-8 w-8 animate-spin text-primary-500" />
        <span className="text-sm text-gray-500">Chargement de la carte...</span>
      </div>
    </div>
  );
}

function MapErrorState({ 
  message, 
  onRetry 
}: { 
  message: string; 
  onRetry: () => void;
}) {
  return (
    <div className="flex h-64 items-center justify-center rounded-2xl border border-gray-200 bg-gray-50">
      <div className="flex flex-col items-center gap-3 text-center px-4">
        <div className="flex h-12 w-12 items-center justify-center rounded-full bg-red-100">
          <AlertCircle className="h-6 w-6 text-red-500" />
        </div>
        <p className="text-sm text-gray-600">{message}</p>
        <button
          onClick={onRetry}
          className="flex items-center gap-2 rounded-lg bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200 transition-colors"
        >
          <RefreshCw className="h-4 w-4" />
          RÃ©essayer
        </button>
      </div>
    </div>
  );
}
```

### Step 4: Mapbox Implementation

Create `apps/patient/src/components/features/tracking/mapbox-map-impl.tsx`:

```typescript
'use client';

// ============================================================
// Mapbox GL Implementation
// 
// Separated from main component for code splitting.
// Only loaded when map is actually needed.
// ============================================================

import { useEffect, useRef, useCallback } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TYPES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface LatLng {
  lat: number;
  lng: number;
}

interface CourierPosition extends LatLng {
  heading: number | null;
  accuracy: number | null;
}

interface MapboxMapImplProps {
  pharmacyLocation: LatLng;
  deliveryLocation: LatLng;
  courierPosition: CourierPosition | null;
  onError: (error: Error) => void;
  onReady: () => void;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONSTANTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Initialize access token from environment
if (process.env.NEXT_PUBLIC_MAPBOX_TOKEN) {
  mapboxgl.accessToken = process.env.NEXT_PUBLIC_MAPBOX_TOKEN;
}

// Casablanca, Morocco as fallback center
const DEFAULT_CENTER: [number, number] = [-7.5898, 33.5731];
const DEFAULT_ZOOM = 13;

// Animation duration for marker movements (ms)
const MARKER_ANIMATION_DURATION = 1000;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MARKER CREATION HELPERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function createPharmacyMarkerElement(): HTMLDivElement {
  const el = document.createElement('div');
  el.innerHTML = `
    <div class="flex h-10 w-10 items-center justify-center rounded-full bg-white shadow-lg border-2 border-primary-500 transform-gpu">
      <svg class="h-5 w-5 text-primary-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"/>
      </svg>
    </div>
  `;
  return el;
}

function createDeliveryMarkerElement(): HTMLDivElement {
  const el = document.createElement('div');
  el.innerHTML = `
    <div class="flex h-10 w-10 items-center justify-center rounded-full bg-green-500 shadow-lg border-2 border-white transform-gpu">
      <svg class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/>
      </svg>
    </div>
  `;
  return el;
}

function createCourierMarkerElement(): HTMLDivElement {
  const el = document.createElement('div');
  el.className = 'courier-marker';
  el.innerHTML = `
    <div class="relative transform-gpu">
      <!-- Pulse ring -->
      <div class="absolute inset-0 animate-ping bg-primary-400 rounded-full opacity-30"></div>
      <!-- Main marker -->
      <div class="relative flex h-12 w-12 items-center justify-center rounded-full bg-primary-500 shadow-lg shadow-primary-500/40 border-2 border-white">
        <svg class="h-6 w-6 text-white courier-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
        </svg>
      </div>
    </div>
  `;
  return el;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COMPONENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function MapboxMapImpl({
  pharmacyLocation,
  deliveryLocation,
  courierPosition,
  onError,
  onReady,
}: MapboxMapImplProps) {
  // Refs
  const containerRef = useRef<HTMLDivElement>(null);
  const mapRef = useRef<mapboxgl.Map | null>(null);
  const pharmacyMarkerRef = useRef<mapboxgl.Marker | null>(null);
  const deliveryMarkerRef = useRef<mapboxgl.Marker | null>(null);
  const courierMarkerRef = useRef<mapboxgl.Marker | null>(null);
  const animationFrameRef = useRef<number | null>(null);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // INITIALIZE MAP
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  useEffect(() => {
    if (!containerRef.current || mapRef.current) return;

    // Check for Mapbox token
    if (!mapboxgl.accessToken) {
      onError(new Error('Mapbox access token not configured'));
      return;
    }

    try {
      // Calculate initial bounds
      const bounds = new mapboxgl.LngLatBounds();
      bounds.extend([pharmacyLocation.lng, pharmacyLocation.lat]);
      bounds.extend([deliveryLocation.lng, deliveryLocation.lat]);
      if (courierPosition) {
        bounds.extend([courierPosition.lng, courierPosition.lat]);
      }

      // Create map
      const map = new mapboxgl.Map({
        container: containerRef.current,
        style: 'mapbox://styles/mapbox/light-v11',
        bounds: bounds,
        fitBoundsOptions: { 
          padding: { top: 60, bottom: 80, left: 40, right: 40 },
          maxZoom: 15,
        },
        attributionControl: false,
        logoPosition: 'bottom-right',
        cooperativeGestures: true, // Require Ctrl+scroll to zoom
      });

      // Handle load
      map.on('load', () => {
        // Add route line source
        map.addSource('route', {
          type: 'geojson',
          data: {
            type: 'Feature',
            properties: {},
            geometry: {
              type: 'LineString',
              coordinates: [
                [pharmacyLocation.lng, pharmacyLocation.lat],
                [deliveryLocation.lng, deliveryLocation.lat],
              ],
            },
          },
        });

        // Add route line layer (dashed)
        map.addLayer({
          id: 'route-line',
          type: 'line',
          source: 'route',
          layout: {
            'line-join': 'round',
            'line-cap': 'round',
          },
          paint: {
            'line-color': '#14b8a6',
            'line-width': 4,
            'line-opacity': 0.5,
            'line-dasharray': [2, 2],
          },
        });

        // Add pharmacy marker
        pharmacyMarkerRef.current = new mapboxgl.Marker({
          element: createPharmacyMarkerElement(),
          anchor: 'bottom',
        })
          .setLngLat([pharmacyLocation.lng, pharmacyLocation.lat])
          .addTo(map);

        // Add delivery marker
        deliveryMarkerRef.current = new mapboxgl.Marker({
          element: createDeliveryMarkerElement(),
          anchor: 'bottom',
        })
          .setLngLat([deliveryLocation.lng, deliveryLocation.lat])
          .addTo(map);

        // Signal ready
        onReady();
      });

      // Handle errors
      map.on('error', (e) => {
        console.error('[MapboxMap] Error:', e);
        onError(new Error(e.error?.message || 'Map error'));
      });

      mapRef.current = map;

    } catch (error) {
      onError(error as Error);
    }

    // Cleanup
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      mapRef.current?.remove();
      mapRef.current = null;
    };
  }, []); // Only run once on mount

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // UPDATE COURIER POSITION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  useEffect(() => {
    if (!mapRef.current) return;

    const map = mapRef.current;

    if (courierPosition) {
      if (!courierMarkerRef.current) {
        // Create courier marker
        const el = createCourierMarkerElement();
        courierMarkerRef.current = new mapboxgl.Marker({
          element: el,
          anchor: 'center',
          rotationAlignment: 'map',
        })
          .setLngLat([courierPosition.lng, courierPosition.lat])
          .addTo(map);

        // Initial rotation
        if (courierPosition.heading !== null) {
          courierMarkerRef.current.setRotation(courierPosition.heading);
        }
      } else {
        // Animate marker to new position
        const marker = courierMarkerRef.current;
        const startLngLat = marker.getLngLat();
        const endLngLat: [number, number] = [courierPosition.lng, courierPosition.lat];
        
        // Use requestAnimationFrame for smooth animation
        const startTime = performance.now();
        
        const animate = (currentTime: number) => {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / MARKER_ANIMATION_DURATION, 1);
          
          // Ease out cubic
          const eased = 1 - Math.pow(1 - progress, 3);
          
          // Interpolate position
          const lng = startLngLat.lng + (endLngLat[0] - startLngLat.lng) * eased;
          const lat = startLngLat.lat + (endLngLat[1] - startLngLat.lat) * eased;
          
          marker.setLngLat([lng, lat]);
          
          if (progress < 1) {
            animationFrameRef.current = requestAnimationFrame(animate);
          }
        };
        
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
        animationFrameRef.current = requestAnimationFrame(animate);

        // Update rotation
        if (courierPosition.heading !== null) {
          marker.setRotation(courierPosition.heading);
        }
      }

      // Pan map to follow courier (with padding)
      map.panTo([courierPosition.lng, courierPosition.lat], {
        duration: MARKER_ANIMATION_DURATION,
        padding: { top: 100, bottom: 100, left: 50, right: 50 },
      });

    } else {
      // Remove courier marker if no position
      if (courierMarkerRef.current) {
        courierMarkerRef.current.remove();
        courierMarkerRef.current = null;
      }
    }
  }, [courierPosition]);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // RENDER
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  return (
    <div 
      ref={containerRef} 
      className="h-full w-full"
      aria-label="Carte de suivi de livraison"
    />
  );
}
```

This is getting long. Let me continue with the remaining critical components and then move to P1.7.

---

## DATABASE SCHEMA

```sql
-- ============================================================
-- ORDER TRACKING DATABASE SCHEMA
-- ============================================================

-- Courier live locations (for real-time tracking)
CREATE TABLE courier_locations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  courier_id UUID NOT NULL REFERENCES couriers(id) ON DELETE CASCADE,
  
  -- Position data
  latitude DECIMAL(10, 8) NOT NULL,
  longitude DECIMAL(11, 8) NOT NULL,
  heading DECIMAL(5, 2),          -- Direction in degrees (0-360)
  speed DECIMAL(5, 2),            -- Speed in km/h
  accuracy DECIMAL(6, 2),         -- GPS accuracy in meters
  altitude DECIMAL(8, 2),         -- Altitude in meters (optional)
  
  -- Timestamps
  recorded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), -- When GPS recorded
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),  -- When inserted to DB
  
  CONSTRAINT valid_latitude CHECK (latitude BETWEEN -90 AND 90),
  CONSTRAINT valid_longitude CHECK (longitude BETWEEN -180 AND 180),
  CONSTRAINT valid_heading CHECK (heading IS NULL OR heading BETWEEN 0 AND 360),
  CONSTRAINT valid_speed CHECK (speed IS NULL OR speed >= 0),
  CONSTRAINT valid_accuracy CHECK (accuracy IS NULL OR accuracy >= 0)
);

-- Indexes for fast lookups
CREATE INDEX idx_courier_locations_order_id 
  ON courier_locations(order_id);
CREATE INDEX idx_courier_locations_recorded_at 
  ON courier_locations(order_id, recorded_at DESC);

-- Order status history (for timeline)
CREATE TABLE order_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  
  -- Status info
  status TEXT NOT NULL,
  notes TEXT,                     -- Optional notes (e.g., "Trafic dense")
  
  -- Audit
  changed_by UUID REFERENCES users(id),
  changed_by_type TEXT,           -- 'patient', 'pharmacy', 'courier', 'system'
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_status_history_order_id 
  ON order_status_history(order_id, created_at);

-- Enable Supabase Realtime for these tables
ALTER PUBLICATION supabase_realtime ADD TABLE orders;
ALTER PUBLICATION supabase_realtime ADD TABLE courier_locations;
ALTER PUBLICATION supabase_realtime ADD TABLE order_status_history;

-- Row Level Security
ALTER TABLE courier_locations ENABLE ROW LEVEL SECURITY;
ALTER TABLE order_status_history ENABLE ROW LEVEL SECURITY;

-- Patients can see locations for their orders
CREATE POLICY "Patients can view their order locations"
  ON courier_locations FOR SELECT
  USING (
    order_id IN (
      SELECT id FROM orders WHERE patient_id = auth.uid()
    )
  );

-- Patients can see their order history
CREATE POLICY "Patients can view their order status history"
  ON order_status_history FOR SELECT
  USING (
    order_id IN (
      SELECT id FROM orders WHERE patient_id = auth.uid()
    )
  );
```

---

## SUCCESS CRITERIA

- [ ] Real-time WebSocket connection with exponential backoff
- [ ] Graceful fallback to polling when WebSocket fails
- [ ] App visibility handling (disconnect when backgrounded)
- [ ] Network recovery detection and automatic reconnect
- [ ] Mapbox map with smooth marker animations
- [ ] Route visualization between pharmacy and delivery
- [ ] Live courier position during IN_TRANSIT
- [ ] Status timeline with completion animations
- [ ] Courier card with call/message actions
- [ ] Toast notifications for status changes
- [ ] Connection state indicator in UI
- [ ] Accessible to screen readers
- [ ] Battery-efficient (no updates when backgrounded)
- [ ] Cost-efficient (lazy load map, cache routes)

---

## NEXT STEP

After validation passes, proceed to:
â†’ `dawa-docs/prompts/phase-1/P1.7-order-history.md`

Reference documentation:
â†’ `dawa-docs/docs/DAWA_MASTER.md`
â†’ `dawa-docs/docs/phases/PHASE_1.md`
